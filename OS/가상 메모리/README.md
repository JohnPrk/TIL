# 가상 메모리

<br />

### 가상 메모리란?

- 프로그램의 모든 코드 및 데이터가 메인 메모리 내에 올라오지 않더라도 프로그램의 실행을 가능케 하는 메모리 기법입니다.
- 가상 메모리는 시스템에 설치된 실제 메인 메모리보다 더 큰 가상의 메모리 공간을 만들기 위해 컴퓨터의 HDD 또는 SSD의 일부를 RAM(Random Access Memory)의 확장으로 활용하고 있습니다.
- 이러한 가상 메모리 기법은 사용자 프로그램이 메인 메모리보다 커져도 된다는 점과 각 프로그램이 더 작은 메모리 공간(실행에 필요한 코드와 데이터만)을 차지하므로 더 많은 프로그램을 동시에 수행할 수 있다는 장점이 있습니다.
- 즉, 전자는 개발자가 메인 메모리의 크기를 신경쓰지 않고 프로그램을 만들 수 있다는 것을 의미하고, 후자는 여러 개의 프로그램이 실행 되더라도 메인 메모리에는 필요한 코드 및 파일만 적재하고 실행할 수 있다는 것을 의미합니다.

<br />

### 가상 메모리 공간

- 프로세스의 가상 주소 공간은 특정 프로세스가 데이터와 코드를 저장하고 관리하는 데 사용할 수 있는 가상 메모리 주소의 범위를 나타냅니다.
- 프로세스가 생성되면 운영 체제는 주소 변환이라는 프로세스를 사용하여 실제 물리적 메모리(RAM)에 매핑되는 고유한 가상 주소 공간을 프로세스에 할당합니다. 이 주소 공간은 다음을 포함한 다양한 세그먼트로 구성됩니다.
- 운영 체제는 각 프로세스의 가상 주소 공간을 관리하여 프로세스가 서로 간섭하지 않도록 합니다.
- 이러한 격리는 하나의 프로세스가 적절한 권한 없이 다른 프로세스의 메모리에 직접 액세스하거나 수정할 수 없기 때문에 안정성과 보안을 유지하는 데 도움이 됩니다.

<br />

### 요구 페이징

- 요구 페이징은 가상 메모리 시스템에서 사용되는 메모리 관리 기술로, 운영 체제(OS)는 전체 프로세스를 미리 메모리에 로드하지 않고 실제로 필요하거나 프로세스에서 요청한 경우에만 프로세스 메모리의 페이지를 메인 메모리에 로드합니다.
- OS는 가상 메모리 주소와 실제 메모리 주소 간의 매핑을 추적하기 위해 페이지 테이블을 유지 관리합니다.
- 프로세스가 실제 메모리에 없는 페이지에 액세스하려고 하면 `Page Fault`가 발생합니다.

<br />

### 유효, 무효 비트 매커니즘

- 요구 페이징에서 `유효 및 무효 비트 메커니즘`은 `운영 체제`에서 현재 메인 메모리에 `적재된 페이지`와 `적재되지 않은 페이지`를 `구분`하는 데 사용됩니다.
- 이 메커니즘은 OS가 가상 및 물리적 메모리 주소 간의 매핑을 관리하고 페이지 오류가 발생했는지 확인하는 데 도움이 됩니다.
- 가상 및 물리적 메모리 주소 간의 매핑을 추적하는 데 사용되는 페이지 테이블의 각 항목에는 페이지가 저장된 물리적 프레임에 대한 정보 외에 유효한(또는 존재하는) 비트가 포함됩니다.
- 유효한 비트는 물리적 메모리에 해당 가상 페이지가 있는 경우 1로 설정되고 그렇지 않은 경우 0으로 설정됩니다.

<br />

### CPU가 메모리를 할당하는 과정 및 페이지 폴트 과정

- CPU가 메모리를 할당하는 과정 및 페이지 폴트의 과정은 다음과 같습니다.
    - `CPU`는 프로그램 카운터(PC)를 통해서 다음 실행할 명령어의 주소를 확인합니다.
    - `CPU`는 `가상 메모리 주소 공간`에 `액세스`하면 하드웨어인 `MMU`(Memory Management Unit)는 해당 `페이지 테이블` 항목을 확인하여 해당 페이지가 실제 메모리에 있는지 확인합니다.
    - 페이지가 없으면 페이지 `Page Fault`가 발생하는데, 이 때 MMU는 `페이지 폴트 인터럽트`를 발생시킵니다.
    - 인터럽트로 인해 프로세스의 정상적인 실행이 일시 `중지`되고, 제어가 OS의 `인터럽트 처리기 루틴`으로 넘어갑니다.
    - 이 때, 프로세스에 대한 `내부 테이블`을 검사해서 메모리 참조가 잘못된 요청(다른 프로세스에게 접근, …)이 아닌지 알아냅니다.
    - 만약 메모리 참조가 잘못 되었다면 프로세스는 `중단`됩니다.
    - 이 후, 보조 저장장치(SSD)로 부터 가져올 공간인 `가용 프레임`을 찾습니다.
    - 가용 프레임의 공간이 있다면 하나의 프레임을 할당합니다.
    - 보조 저장장치의 읽기 작업이 끝나면 스왑 공간에서 프레임으로 `페이지`를 가져옵니다.
    - 프레임은 가용 프레임 페이지 리스트에서 제거(분리)됩니다.
    - 페이지 테이블의 메모리 유효 비트를 1로 수정해줍니다.
    - 인터럽트에 의해 중지되었던 프로세스의 명령어를 다시 수행합니다.
    - 이 때, 명령어의 진행 여부와 관련 없이 다시 처음부터 명령어가 실행됩니다.
- 극단적인 경우이지만, 프로그램에 필요한 페이지가 하나도 안 올라와 있는 상태에서도 실행할 수 있습니다.

<br />

### 요구 페이징의 필수적 요구 사항

- 요구 페이징의 필수적 요구 사항은 페이지 폴트 오류 처리 후에 명령어 처리를 다시 시작할 수 있어야 합니다.
- 페이지 폴트가 발생하기 직전의 상태를 가지는 레지스터 값을 되돌릴 수 있어야 합니다.
- 예를 들어서 명령어 실행 중에 데이터를 가져오다가 페이지 폴트가 일어나게 되면 데이터를 메모리에 적재시키고 다시 처음부터 명령어를 실행하게 됩니다.

<br />

### 가용 프레임 리스트

- OS는 물리적 메모리에서 비어 있는 프레임을 찾기 위해 사용 가능한 `가용 프레임 리스트`를 참조합니다.
- 페이지 폴트 중에 사용 가능한 프레임 리스트에서 적합한 프레임을 찾으면 해당 프레임이 목록에서 `제거`(또는 `할당된 것`으로 표시)됩니다.
- `보조 저장소`에서 `물리적 메모리`의 할당된 프레임으로 요청된 페이지를 로드합니다.
- 유효한 비트를 1로 페이지 테이블을 수정하고, 페이지가 현재 저장되어 있는 `프레임 주소`로 페이지 테이블을 수정합니다.
- `프레임`이 `페이지`에 할당되면 할당이 `해제`될 때까지 다른 페이지에서 더 이상 사용할 수 없습니다.
- 프레임이 `할당 해제`되면(예: 프로세스가 종료되거나 페이지가 교체될 때) OS는 해제된 프레임을 다시 `가용 프레임 리스트`에 추가하여 향후 할당에 사용할 수 있도록 합니다.

<br />

### 스왑 공간 I/O

- 스왑 공간에서의 디스크 I/O는 일반적으로 파일 시스템의 입, 출력보다 빠릅니다.
- 이에 대한 이유는 다음과 같습니다.
    - 스왑 공간은 파일 시스템보다 큰 블록을 사용합니다.
    - 스왑 공간의 I/O 작업은 `파일 찾기`나 `간접 할당 방법` 등을 사용하지 않는다.
        - 스왑 공간은 일반적으로 디스크의 연속 블록으로 구성되어 있습니다.
        - 따라서, 분산 파일 시스템과 달리 디스크 헤드가 서로 다른 위치 사이를 이동해야 하는 파일 검색 시간이 감소하기 때문에 빠른 성능을 가졌다고 할 수 있습니다.
        - 파일 시스템에서 데이터는 종종 간접 블록 또는 익스텐트를 통해 블록을 할당하는 것과 같은 간접적인 방법을 사용하기 때문에 추가적인 참조 및 데이터 구조에 대한 오버헤드가 있습니다.
        - 하지만, 스왑 공간 같은 경우에는 운영체제가 직접 엑세스하기 때문에 I/O가 빠르다고 할 수 있습니다.

<br />

### 메모리 과할당

- 다중 프로그래밍에서 메모리 과할당은 여러 프로세스가 시스템에서 사용할 수 있는 제한된 메모리 리소스를 놓고 경쟁하여 메모리가 고갈되거나 시스템 성능이 저하되는 상황을 말합니다.

<br />

### 페이지 교체 알고리즘

- 페이지 폴트 발생시 가용 프레임 리스트가 존재하지 않을 때, 운영체제는 페이지 교체 알고리즘을 사용하게 됩니다.
- 가용 프레임 리스트가 존재하지 않는다면 디스크에 대한 엑세스가 두 번이기 때문에 오버헤드가 굉장히 크다고 할 수 있습니다.
- 이러한 오버헤드는 `변경 비트`를 사용해서 부분적으로 감소시킬 수 있습니다.
- 변경 비트(더티 비트 또는 수정된 비트라고도 함)는 페이지가 물리적 메모리에 로드된 이후 수정(기록)되었는지 여부를 나타내는 가상 메모리 시스템의 페이지 테이블 항목에 있는 플래그입니다.
- 이 비트는 일부 페이지 교체 알고리즘에서 중요한 역할을 하며 운영 체제(OS)가 새 페이지를 위한 공간을 확보해야 할 때 메모리에서 제거할 페이지를 결정하는 데 도움을 줍니다.
- FIFO 알고리즘
    - 가장 먼저 실행된 페이지를 교체하는 방식입니다.
    - FIFO 페이지 교체 알고리즘은 이해하기도 쉽고 프로그래밍 하기도 쉽습니다.
    - 하지만, 특정한 상황에서는 성능이 떨어지고 Belady의 모순이 발생할 수 있습니다.
- 최적 페이지 교체 알고리즘
    - 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아서 교체하는 방식입니다.
    - 최적 페이지 교체 알고리즘은 Belady의 모순이 발생하지 않습니다.
    - 하지만, 앞으로 메모리를 어떻게 참조할 것인지를 미리 알아야하기 때문에 구현할 수 없는 알고리즘입니다.
    - 이러한 알고리즘은 다른 알고리즘을 평가하는 기준으로 사용됩니다.
- LRU 알고리즘
    - 가장 오랫동안 사용되지 않는 페이지를 교체하는 방식입니다.
    - 이러한 LRU 알고리즘은 두 가지 방법으로 구현이 되어집니다.
        - 계수기 : 페이지를 요청한 시간 필드를 추가해서 이를 참고하여 교체합니다.
        - 스택 : 더블리 링크드 리스트 형태로 가장 최근에 사용된 페이지를 리스트의 제일 처음으로 이동시키고 이를 참고하여 교체합니다.
        - LRU 알고리즘도 Belady의 모순이 발생하지 않습니다.
- LRU 근사 알고리즘
    - LRU 알고리즘을 지원할 수 있는 하드웨어가 많지 않기 때문에 쉬운 FIFO 형태의 알고리즘을 사용해야합니다.
    - 하지만, 많은 시스템에서 `참조 비트`의 간단한 형태는 지원하기 때문에 이를 활용한 형태의 알고리즘이 존재합니다.
        - 클록 기회 알고리즘
            - 원형 리스트 형태의 FIFO를 구성해서 페이지가 사용되면 참조 비트를 1로 수정하고 그렇지 않다면 참조 비트를 0으로 수정합니다.
            - 페이지 교체는 참조 비트가 0인 페이지에 한해서 진행합니다.
    - 개선된 클록 기회 알고리즘
        - 여기에서 참조 비트 뿐만 아니라 변경 비트까지 활용해서 우선순위를 설정할 수 있습니다.
- 계수-기반 페이지 알고리즘
    - LFU와 MFU 알고리즘이 있지만 비용이 높아서 잘 사용되지 않습니다.

<br />

### 프레임 할당

- 최소의 프레임 할당
    - 페이지 폴트율을 줄이기 위함입니다.
    - 프로세스 당 최소 프레임 수는 아키텍처에 의해 정의되는 반면 최대 수는 사용 가능한 물리 메모리양에 의해 결정됩니다.
- 할당 알고리즘
    - 균등 할당 : 프로세스 별로 같은 프레임을 할당 받습니다.
    - 비례 할당 : 프로세스의 크기에 맞춰서 프레임을 할당 받습니다.
    - 하지만, 이러한 할당 알고리즘은 프로세스의 우선순위를 고려하고 있지 않습니다.
- 전역 대 지역 할당
    - 전역 할당
        - 전역 할당에서 운영 체제는 전체 물리적 메모리를 공유 리소스 풀로 취급하고 엄격한 프로세스별 제한 없이 필요에 따라 프로세스에 메모리 프레임을 할당합니다.
        - 프로세스에 페이지 폴트가 발생하면 운영 체제는 프레임이 속한 프로세스에 관계없이 전역 페이지 교체 알고리즘을 사용하여 교체할 프레임을 선택합니다.
        - 전역 할당의 가장 큰 문제는 프로세스가 다른 프로세스에도 영향을 미친다는 것입니다.
    - 지역 할당
        - 지역 할당에서 운영 체제는 각 프로세스에 고정된 수의 메모리 프레임을 할당하여 분할된 메모리 공간을 만듭니다.
        - 프로세스에 페이지 오류가 발생하면 운영 체제는 특정 프로세스에 할당된 프레임만 고려하여 로컬 페이지 교체 알고리즘을 사용하여 교체할 프레임을 선택합니다.
        - 지역 할당의 가장 큰 문제는 지역 할당된 유후 공간이 생길 수 있다는 것입니다.
        - 일반적으로 전역 할당이 지역 할당보다 더 좋은 성능을 발휘하기 때문에 전역 할당이 주로 사용됩니다.
    - 가용 프레임 리스트의 개수가 0이 되기 전에 특정 임계값 아래로 떨어지면 모든 프로세스에서 페이지를 회수하는 `리퍼 루틴`이 시작되게 됩니다.
    - 일반적으로 커널 `리퍼 루틴`을 LRU 근사 알고리즘을 사용합니다.

<br />

### 스레싱

- 스레싱(Thrashing)이란 페이지 부재율(Page fault)이 증가하여 CPU 이용율이 급격하게 떨어지는 현상을 의미합니다.
- 이는 하나의 프로그램에 필요한 가용 프레임을 할당 하기 위해 프로그램의 가용 프레임을 뺏는 상황에서 프레임을 뺏긴 프로그램도 다시 가용 프레임을 할당하기 위해 다른 프로그램의 가용 프레임을 연쇄적으로 뺏고 뺏기는 것을 의미합니다.
- 이 때, CPU 이용률이 떨어지기 때문에 CPU 스케쥴러는 새로운 프로세스를 추가해서 다중 프로그래밍의 정도를 더 높이게 되는 악순환을 만들게 됩니다.
- 이러한 스레싱은 지역 교체 알고리즘 또는 우선순위 교체 알고리즘을 통해서 스레싱의 영향을 제한할 수 있습니다.
- 하지만, 이러한 것도 모든 스레싱을 해결하는 것이 아니기 때문에 몇 가지 방법을 통해서 해결하고자 합니다.
    - 지역성 모델 : 여러 프로그램이 동시에 실행되고 메모리 리소스를 놓고 경쟁하는 현상이 발생 했을 때 Locality Model은 운영 체제가 높은 지역성을 나타내는 프로그램에 우선 순위를 지정해야 하는 것을 의미합니다.
    - 작업 집합 모델
        - 작업 집합 모델도 동일하게 지역성을 토대를 바탕으로 가장 최근 접근한 프레임이 이후에도 또 참조될 가능성이 높다는 가정에서 출발합니다.
        - 최근 일정 시간동안 참조된 페이지들을 하나의 집합으로 만들고, 이 집합에서
        - 최근 참조했던 페이지와 연관되는 다른 페이지의 집합을 작업 집합이라고 하고
    - 페이지 폴트 빈도
        - 작업 집합 모델의 경우 충분한 페이지를 할당하지 않으면 작업 집합에 있는 페이지를 물레 메모리에 유지하기가 힘든 특성을 가지고 있습니다.
        - 또한 작업 집합 모델에서는 어떤 프레임을 물리 메모리에 유지해야 하는 지 알 수있지만 프로세스에 프레임을 얼마나 할당해야 하는지는 알 수 없습니다.
        - 페이지 폴트 빈도는 페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하는 방식입니다.
        - 페이지 부재 빈도 방식에서는 페이지 부재 비율의 상한선과 하한선을 설정합니다.
        - 페이지 부재 비율이 상한선을 초과하면 할당한 프레임이 적다는 것을 의미하므로 프레임을 추가하여 늘립니다.
        - 반대로 페이지 부재 비율이 하한선 밑으로 내려가면 메모리가 낭비된다는 의미이므로 할당한 프레임을 회수한다.
        
        
<br />

### _참고자료_
* 운영체제(Operatating System) 10판 - Chapter 10 가상메모리

<br />
