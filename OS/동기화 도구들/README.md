# 동기화 도구들

<br>


### 임계구역의 문제를 해결하기

- `경쟁 조건`(Race Condition)이란 멀티 프로세스 환경에서 프로세스 혹은 스레드가 예측할 수 없는 순서로 동시에 공유 리소스에 접근해서 잘못된 계산 결과값을 도출하는 상황을 의미합니다.
- 이렇게 공유 리소스에 접근하는 코드를 `임계 구역`(Critical Section)이라고 하고, 임계 구역 내에서 발생한 문제를 `임계 구역 문제`라고 합니다.
- 임계 구역 문제를 해결하기 위해 공유 리소스 접근에 대한 동기화를 해줘야하는데, 이 과정에 3가지 조건을 만족시켜야합니다.
<br>

### 임계 구역 문제를 해결하는 3가지 조건

- 상호 배제(Mutual Exclusion) : 첫 번째 프로세스가 임계 구역 내의 코드를 실행하고 있다면 두 번째 프로세스는 임계 구역의 코드를 실행할 수 없고 대기해야한다.
- 진행(Progress) : 임계 구역 내에 접근한 프로세스가 없다면 어떤 프로세스든 임계 구역 내의 코드를 실행할 수 있다.
- 한정된 대기(bounded Waiting) : 임계 구역에 진입하기 위해서 대기는 한정된 횟수가 있어야 한다.
<br>

### 임계 구역 문제를 해결하는 기본 아이디어 → 피터슨 알고리즘

- `피터슨 알고리즘`은 임계구역에 대한 `고전적인 소프트웨어 기반 아이디어`입니다.
- 따라서, 현대 컴퓨터 구조의 `load`, `store` 같은 기본 기계어를 수행하는 환경에서는 정확히 동작할 수 없다는 특징을 가지고 있습니다.
- 먼저, 피터슨 알고리즘은 `두 개의 프로세스`로 한정을 짓고,
- `flag 배열`과 `turn`이라는 변수로 임계영역에 들어갈 프로세스(혹은 스레드)를 결정하는 방식이다.
- 이 때, flag 배열은 각 프로세스가 임계 영역으로 진입할 준비가 되었다는 것을 표시하고,
- turn은 임계 구역에서 실행되는 프로세스를 가리킵니다.
    
    <img width="700" alt="image" src="https://user-images.githubusercontent.com/88137420/227510725-0eed338e-500c-4006-b1ec-6bfd51f6768e.png">

    
- 위의 코드를 보면, 프로세스 i가 임계 구역에 들어가기 위해서는
    - 자신의 flag 값을 true로 변경하고
    - turn을 프로세스 j에게 돌리게 됩니다.
    - 이 때, turn을 j로 돌리는 이유는 프로세스 j가 임계구역에 있는 확인하기 위함입니다.
    - 이 때, 프로세스 j가 임계 구역에 진입 했다면 프로세스 i는 `while 조건문`에 갇혀서 대기하게 됩니다.
    - 이 후 프로세스 j가 자신의 임계구역 내의 코드를 처리하고 flag 값을 바꿔주면 그제서야 프로세스 i가 임계 구역에 진입할 수 있습니다.
- 이러한 피터슨 알고리즘은 임계 구역 문제 해결의 3가지 조건을 만족합니다.
- 하지만, 피터슨 알고리즘은 임계 영역을 기다리는 프로세스가 계속해서 while 루프를 계속 돌면서 `자원의 낭비`를 하고 있는 큰 문제를 가지고 있고, 이를 `busy waiting`이라고 합니다.
<br>

### 임계 구역 문제를 해결하는 하드웨어 기반 해결책

- 메모리 장벽 : 메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어를 제공하여 다른 프로세서가 메모리 변경을 알 수 있도록 합니다.
- 하드웨어 명령어
    - test_and_set() : 하드웨어 명령어는 데이터의 `접근` → `연산` → 연산 결과 `저장`의 과정을 하나의 단위의 작업으로 수행할 수 있는 하드웨어적인 지원을 해주는 것이다.
    - 이 때, test_and_set()은 CPU의 atomic 명령어이기 때문에 실행 중간에 `간섭 받거나 중단 되지 않고`, 멀티 코어 환경에서 동시에 메서드를 호출하더라도 CPU가 알아서 순서를 지정해줘서 처리하는 특성을 가지고 있습니다.
<br>

### 임계 구역 문제를 해결하는 소프트웨어 기반 해결책

- 임계 구역 문제에 대한 하드웨어 기반 해결책은 복잡할 뿐 아니라 응용 프로그래머는 사용을 할 수 없는 특징을 가지고 있습니다.
- 대신 은양체제 설계자는 임계구역 문제를 해결하기 위해 다음과 같은 3가지 소프트웨어 기반 해결책을 제시합니다.
<br>

### 뮤텍스 vs 세마포어

- 뮤텍스는 `동기화 대상`이 1개로 정해져있지만, 세마포어는 동기화 대상이 1개 이상일 수 있습니다.
- 뮤텍스는 임계 구역에서 진행 중인 프로세스만이 락을 해제할 수 있지만, 세마포어는 `signal`을 날리는 프로세스에 의해 락이 해제가 될 수 있습니다.
- 세마포어는 `공유 자원의 접근 가능 개수`를 나타내는 `일종의 변수`로써 `소유 개념이 아니지
만`, 뮤텍스는 임계 구역에 진입한 프로세스(혹은 쓰레드)가 `잠시 소유하였다가` 작업이 끝나면 `반환`하는 개념이다.
- 뮤텍스와 세마포어는 `목적`에 따라서 다르게 락을 거는 방식입니다.(제 생각이라 틀릴 수 있습니다)
    - 예를 들어, 공유 데이터에 대한 프로세스의 접근은 무조건 뮤텍스 방식을 통해서 상호 배제를 보장할 수 있습니다.
    - 세마포어의 경우는 공유 리소스의 개념을 DB Connection Pool과 같은 개념으로 확장해야 합니다.
    - 즉, DB Connection Pool 내부에 Connection들이 존재할 경우, 그 갯수만큼의 카운팅을 가진 세마포어를 이용해서 Connection들에 프로세스를 할당할 수 있는 개념으로 받아들여야 합니다.
    - 따라서, 애초에 `목적`이 다르고 `공유 데이터의 형태`도 다르다고 생각합니다.
<br>

### 모니터

- 모니터란 프로그래밍 언어차원에서 공유 데이터의 접근에 관한 문제를 빠르게 해결할 수 있도록 도와주는 방법입니다.
- 세마포어를 사용할 때는 임계 구역에 `명시적`으로 `상호 배제 로직`을 구현해야합니다.
- 이 과정에서 개발자의 실수나 명시적으로 세마포어를 구현하지 않았을 경우에는 병행성 제어를 정확하게 처리할 수 없다는 문제를 가지고 있습니다.
- 모니터는 이러한 문제를 해결하고자 만든 방법입니다.
- 먼저, 모니터는 상호 배제 로직을 `추상화`해서 `프로시져 형태`로 만듭니다.
- 즉, 상호 배제를 보장하는 일련의 데이터와 함수를 하나의 집합으로 묶어서, 모니터를 통해서 상호 배제를 사용할 수 있는 환경을 만드는 것을 의미합니다.
- 이를 통해 개발자가 일일히 로직을 구현하지 않아도 되기 때문에, `생산성`과 `안정성`에 큰 이점이 있습니다.
- 모니터는 주로 고급 프로그래밍 언어에서 제공하는 방식인데, 자바의 경우 **`synchronized`** 키워드를 통해 상호 배제 로직을 사용할 수 있도록 구현되었습니다.
<br>

### 라이브니스

- 교착상태(Dead Lock) : 두 개 이상의 프로세스(혹은 스레드)가 서로가 가진 리소스를 무한정 기다리는 상태를 의미합니다.
- 우선순위 역전(Priority inversion)
    - 우선순위가 낮은 프로세스가 우선순위가 높은 프로세스가 작업을 완료하는 데 필요한 리소스를 보유하고 있을 때 동시 프로그래밍에서 발생할 수 있는 현상입니다.
    - 이와 같은 문제를 우선순위 상속 프로토콜로 해결하게 되는데,
        - 우선순위 상속 프로토콜은 자원을 가지고 있는 작업의 우선순위를 일시적으로 자원을 기다리는 가장 높은 우선순위의 작업의 우선순위로 올려준다.
        - 이렇게 하면 우선 순위가 높은 작업이 작업을 계속할 수 있고 우선 순위 반전을 방지할 수 있습니다.

<br>
