# 3주차

<br>

- ### Q&A
    - 인수 테스트와 단위 테스의 `차이`
        - 인수 테스트와 단위 테스트의 `목적`이 다르다.
        - 하지만 같은 기능을 검증하는데 사용할 수 있다.
        - 그 기능의 변경이 바뀌거나 세부 구현이 바뀔 때, `인수 테스트는 변하지 않아야 하지만` 단위 테스트는 바껴야한다.
        - 현재 코드를 작성할 때는 같은 부분을 작성 한다고 생각해서 불 필요하다고 느낄 수 있지만, 해당 부분이 변경이 생기게 되면 차이가 생길 수 밖에 없다.
    - `mock`의 경우 `stub`처럼 리턴 값을 정할 수 있지 않나요?
        - 가능하다.
        - 하지만 mock 같은 경우에는 `행위`를 검증하는 것이고, stub 같은 경우에는 `상태`를 검증하는 것이다.
    - `MSA 구조`일 때는 인수 테스트를 어떻게 할 수 있을까요?
        - 저도 시도를 많이 해보고 있는 부분이긴 하다.
        - 이번 주 미션에서 `인수 테스트`에 `통합 테스트`의 개념을 곁들여서 `외부 서비스에 의존적인 테스트`를 만들어보는 것을 다루게 된다.
        - 그 부분을 설명할 때 다시 설명 해주겠다.
        - 인수 테스트라도 `‘무조건 블랙박스 테스트여야 하는 것은 아니라'`고 생각한다.
        - 이런 경우에는 mocking도 충분히 활용 할 수 있을 것 같다.
        - `테스트 컨테이너`라던지 다른 여러가지 방법을 통해서 시나리오를 검증할 수는 있을 것 같다.
        - MSA 같은 경우에는 각각의 모듈을 검증하는 통합 테스트를 `지양` 한다고 알고 있고 대신 `모듈 내부의 테스트`와 `모니터링`을 바탕으로 각 모듈간의 `유기적인 동작을 검증`하는 추세라고 알고 있다.
    - Repository 관련 코드의 중복을 어떻게 해결할 수 있을까요?
        - 질문 추가 설명 : findById() 메서드를 사용 하다보면 Exception 처리라던지 Optional 문제라던지 이런 중복 처리 코드들이 발생할 텐데 그렇게 되면 서비스가 비대 해지는 것 같았다.
        - 강바다 : 저희회사는 ExtendRepository 라는 클래스를 만들어서 사용하고 있는데 이게 원래 의도대로 잘 사용을 안하더라고요, 여기에 비즈니스 로직도 너무 많이 들어가고.…(레파지토리를 하나 더 만들어서 계층을 나눴다)
        - App Jo : 저는 조회용(R) 서비스와 생성, 수정, 삭제용(CUD) 서비스는 분리하는 편이고, 엔티티만 반환하는 서비스도 분리하는 편이에요(커맨드와 쿼리를 분리해서 서비스를 사용한다)
        - 최현웅 : 서비스 레이어 상위 계층에서 파사드 계층을 둬서 다른 서비스와의 의존성을 줄입니다
        - 권승철 : 비슷한 이야기가 저번 기수때도 나왔었는데 아래 이야기도 읽어볼만 할 것 같아요 ~ [https://github.com/next-step/atdd-subway-map/discussions/489](https://github.com/next-step/atdd-subway-map/discussions/489)
        - 브라운 : 이러한 이유 때문에 ‘각 아키텍처들이 발전을 하는게 아닌가’라는 생각을 했습니다. 서비스 레이어가 비대 해지는게 두려워서(?) 이런 고민을 하시는데, 그 전에는 그 조차도 계층이 나눠지지 않았을 것이고 그게 발전하다보니깐 레이어드 아키텍처도 나오고, 이 후에 조금 더 격리가 필요하다고 느끼니깐 헥사고날 아키텍처도 나왔던 것 같다. 이를 봤을 때, 어떤 방식이 무조건 좋은 것은 아닌거 같다. 예전에 ‘프로젝트 규모 사이드 프로젝트에서 헥사고날 아키텍처를 써봤는데 너무 번거롭고 귀찮은거 같았다. 기능을 하나 추가 하는데, 이 기능 추가를 위한 패턴화된 객체들이 너무 많아서 ‘이게 좋은게 맞나’라는 생각을 했습니다.
    - 현업에서 DB조회가 필요한 유효성 검증을 어떤 클래스에서 처리 하는지 궁금합니다
        - ‘`유효성 검증의 책임`은 누구인가?’라고 생각해봤을 때, 로직을 가지고 있는 객체를 떼어 냈을 때, 유효성 검증이 필요 없는 상황이 된다면 설계를 잘 했다고 생각한다.
    - MSA구조에서 테스트 픽스쳐 생성을 위한 API가 다른 도메인에 있는 경우 테스트 픽스쳐 생성 및 제거를 위해 `feign` 등을 통해 별도의 `게이트웨이`를 뚫어도 될지 궁금합니다.
        - 저는 테스트 픽스쳐 만들 때 중요하게 생각하는 부분은 일단 프로덕션 코드에서 중요하게 생각하는거랑 다를 수 있다.
        - 가독성이 중요하고 프로덕션 코드와 비슷하게 해당 도메인이나 모듈이 떨어져 나갔을 때도 독립적으로 잘 목적을 잘 수행할 수 있는지가 중요할 것이라고 생각한다.
        - 그래서 별도의 게이트웨이를 뚫어서 테스트 픽스쳐를 만드는거까지는 좋다고 생각 하나 이게 다른 인수 테스트를 만들고 혹은 기능을 제거하는 데에 있어서 `발목`을 잡을 수 있을 수 있는 요소가 될 수 있다고 생각한다.
        - 이러한 부분에 대한 인지가 있고서 사용은 나쁘지 않은 것 같다. → `트레이드 오프`
    - 인수 테스트 : 실무에서 적용할 수 있는 `유연성 있는`(코드의 변경에 수정을 최소화 할 수 있는) 테스트 코드 → `블랙박스 테스트`
    - 인수 테스트와 단위 테스트의 트레이드 오프
        - 인수 테스트는 시나리오 기반의 역할을 검증하는 역할도 있지만, 개발 방법론인 관점에서 보면 시작 지점과 끝 지점을 명확히 만들어주는 개발 방법론(도구)라고 생각하면 좋을꺼 같다.
        - 이해도에 따라서 다를 수 있겠지만, 이해도가 충분하다면 `Inside Out 사이클`로 단위 테스트를 만들어 나가는게 결과물로 만들어지는 테스트가 `좀 덜 깨질 수 있고 관리하기가 수월한`거는 사실이다.
        - 하지만, 우리가 코드를 구현할 때 모든 부분을 이해하고 설계할 수 있는 상황이 아닐 수 있기 때문에 그 어느 `적정선`을 잘 지키는게 중요한거 같다.
<br>

- ### 2주차 피드백
    - `테스트에서만` 사용되는 프로덕션 코드?
        - 테스트만을 위한 프로덕션 코드는 지양 하지만 과하게 사용하는 것이 아니라면 제한적으로 허용
        - [예시] 도메인 객체에 id를 추가하기 위해서라면 repository로 저장을 해야 하는데,, 그렇게 하는 것보다 id 값을 직접 넣어주는 생성자를 하나 만드는 정도는 괜찮지 않을까?
            
            <img width="700" alt="Untitled" src="https://user-images.githubusercontent.com/88137420/222066307-15616c18-6508-4a1d-ab54-3363a741b272.png">
            
        - 그렇지 않다면 ‘stubbing’이나 ‘ReflectionTestUtils’와 같은 걸로 할 수는 있긴 하다,,,
            
            <img width="700" alt="Untitled1" src="https://user-images.githubusercontent.com/88137420/222066329-6bada36b-35d4-40cb-8186-0c55c2eb5114.png">
            
            <img width="700" alt="Untitled2" src="https://user-images.githubusercontent.com/88137420/222066345-fdded657-d833-4c6a-9029-73ca92015305.png">
            
        - 과연 ID가 필요할까? → 객체 간 비교
            
            <img width="700" alt="Untitled3" src="https://user-images.githubusercontent.com/88137420/222066360-0a7de936-2dce-42b0-a8ac-db6bbba1bb53.png">
            
    - `의존성?`
        - 의존이 무조건 나쁜건 아니다.
        - 객체 지향에서 의존은 `‘끊어내야 한다’`와 같은 의미가 아니라 `‘잘 사용해야 한다’`는 의미를 포함하고 있다.
        - `객체지향 관점`에서 내가 가지고 있는 책임과 다른 객체의 책임을 정확히 나눠 보고 책임을 `위임` 하면서 코드를 `책임`을 기준으로 한 객체 지향 설계를 할 수 있다. 이를 통해 각 객체의 `역할`이 분명해질 수 있다.
        - 다른 객체에 너무 자주 get을 해서 상태를 가져온다? → 그러면 ‘애초에 두 객체는 나뉠게 아니라 하나의 객체여야 하는게 아닌가?’ 라는 생각을 해보게 된다. → 클린코드를 지향 하지만, 이런 문제들을 만나면 ‘설계를 잘 한게 맞나?’ 라는 의문이 들 수 있다.
<br>
    
- ### 통합 테스트
    - 단위 테스트로 `충분`한가?
        - 인수 테스트를 통해서 전반적인 시나리오를 작성 하고 도메인을 이해 하고 큰 그림을 그렸다 한다면
        - 단위 테스트를 통해서 작은 그림을 그릴 수 있었다.
        - 그렇다고 한다면, 내가 만든 이 `애플리케이션`과 `DB` 혹은 `외부 서비스`와 `유기적`으로 잘 연결되고 동작하는지는 어떻게 확인 하고 검증을 할 수 있을까?
        - 이를 위해서 인수 테스트를 만들기에는 너무 번거로운 부분이 생기게 된다.
        - 따라서 `E2E 테스트`를 통해서 보완할 수 있지만 실제 DB, 라이브러리, 서비스 등을  사용하게 되면 테스트를 돌리는데 시간이 너무 많이 걸리는 `한계`를 가지고 있다.
        - 통합 테스트 : 애플리케이션에서 다른 서비스들과 서로 연결 되어서 잘 동작 하는지 확인하는지만 목적으로 하는 테스트
        - 💡 예전에는 소프트웨어가 복잡하지 않아서 한 명의 개발자가 하나의 모듈을 담당해서 개발을 했는데, 이 때 자신의 모듈을 검증하는 것을 ‘단위 테스트’라고 했고 다른 사람이 만든 모듈과 내 모듈이 유기적으로 잘 동작하는지 확인 하는 것을 ‘통합 테스트’라고 했다.
    - 통합 테스트의 `목적`
        - ‘`독립적인 단위의 기능`이 `다른 단위의 기능`과 잘 연결되어 동작하는가?’를 검증 한다.
        - 예시 : 데이터 베이스, 외부 라이브러리, …
    - 통합 테스트의 `구분` (넓은 의미 vs 좁은 의미)
        - 넓은 의미 : 전체적인(많은) 모듈들이 같이 잘 동작 하는지 검증 (보통은 ‘E2E 테스트’라고 함)
            
            <img width="700" alt="Untitled4" src="https://user-images.githubusercontent.com/88137420/222066387-d7a0f38d-379b-4bf3-a45b-a5122121ee47.png">
            
        - 좁은 의미 : 나의 모듈과 다른 모듈 / 나의 애플리케이션과 다른 라이브러리(혹은 DB, API) 요소들만 잘 연결되고 동작하는지 검증
            
            <img width="700" alt="Untitled5" src="https://user-images.githubusercontent.com/88137420/222066416-3c2139e1-ab0f-4098-be2f-fd1f4a1d1213.png">
            
            <img width="700" alt="Untitled6" src="https://user-images.githubusercontent.com/88137420/222066441-3721b5f5-959e-45a2-9d56-24d03d324b2f.png">
            
            ⇒ 지난 시간에 단위 테스트를 소개할 때, 실제 객체를 이용한 단위 테스트랑 통합 테스트가 겹치는 것 같다고 느낄 수 있는데, 이는 테스트의 목적이 다르다한들 같은 형태의 테스트 코드일 수 있기 때문에 테스트의 이름에 너무 연연하지 않아도 될 것 같다.
            
    - 외부 프로세스에 따라 구분 (관리 의존성 vs 비관리 의존성)
        - 관리 의존성 : DB 같은 경우 내 애플리케이션을 통해서만 DB에 접근할 수 있고 이를 관리 의존성이라고 한다.
        - 비관리 의존성 : 꼭 내 애플리케이션이 아니더라도 다른 어드민 툴이라던지 다른 방식으로도 해당 의존성에 상태를 바꿀 수 있다면 비관리 의존성이라고 한다. 예시로는 `메시지큐`라던지 아예 `외부 서비스`(깃허브, 아임포트)들이 있다.
        - 관리 의존성의 경우, 실제 환경을 가져다 쓰는 방식으로 통합 테스트를 구현하는 것이 편하다.
        - 비관리 의존성의 경우, 대체를 해서 통합 테스트를 구현하는 것이 편할 수 있다.
        - 사실 이게 그렇게 중요하지는 않다.
        - 관리 의존성이든 비관리 의존성이든 테스트를 만들어야 하는데, 그럼 그 의존성을 어떻게 할 것인가?
        → 실제 외부 의존성을 사용할 것인지?
        → Stub을 이용할 것인지?
        → Fake나 다른 테스트 더블로 대체할지?
    - 실제 프로세스를 사용해서 외부 의존성 처리
        
        <img width="700" alt="Untitled7" src="https://user-images.githubusercontent.com/88137420/222066476-2afa2103-46f8-4f85-b843-37c2b5320389.png">
        
        - 만들 때는 좋았지만 운영을 해보다보니 불편한 점들이 생겼다.
            - 사용 : 실제 깃헙에 브랜치 생성 및 PR 생성 / 머지 등 필요한 활동 직접 수행 (외부 API에 콜을 보내는 방식으로 사용)
            - 불편했던 점 : 속도가 현저히 저하 / 깃헙 동작에 의존적인 테스트
    - `Stubbing`을 사용해서 외부 의존성 격리
        
        <img width="700" alt="Untitled8" src="https://user-images.githubusercontent.com/88137420/222066498-ba857d8b-9ee3-4f45-b153-9612896da5c7.png">
        
        - 문제가 되었던 부분 :
            - `Spring Context`의 캐싱된 것을 사용하는 조건이 `컨테이너에 있는 빈이 오염되지 않아야`하는 것인데, Stubbing을 위해서 Mock을 사용하게 되면 `MockBean`, `SpyBean`을 사용하게 되고 이로 인해 Spring Context를 사용 하지 못하고 다시 컨테이너를 띄워야하는 문제점이 발생했다. → 속도가 떨어짐
            - 프로덕션 코드에 의존적인 테스트 코드 : 테스트 코드 자체가 블랙박스 코드가 될 수 없다. 해당 로직이 바뀔 때마다 큰 고통을 겪었다.
    - 요청과 응답을 자체 서비스에서 할 수 있게 하는 방법은 없을까? → `Fake 방식`
        
        <img width="700" alt="Untitled9" src="https://user-images.githubusercontent.com/88137420/222066521-7b7ba05e-6901-41b9-8439-752b02e38905.png">
        
        - 테스트 프로파일을 통해서 테스트 할 때는 외부 API 콜하는 요청을 내부 API을 콜하게끔 해서 딜레이 등을 줄여봤다.
        - `Fake 객체`가 뜨다 보니 따로 stubbing이나 mocking을 해줄 필요가 없게 되면서 캐싱된 Spring Context를 사용할 수 있게 되었다.
<br>
    
- ### 외부에 의존하는 인수 테스트 예시 : 서드 파티 로그인
    - Oauth 2.0
        
        <img width="700" alt="Untitled91" src="https://user-images.githubusercontent.com/88137420/222066543-69c5b39c-cac4-40a6-9a94-f233fc05e7a3.png">
        
    - 전체적인 흐름
        1. 사용자가 서버(넥스트 스텝)에 인증 요청을 하게 되면 깃허브 인증 페이지를 통해서 아이디와 비밀번호를 통해서 인증 값을 받을 수 있다.
        2. 하지만 우리 과정에서는 그게 없기 때문에 외부 서비스에 있는 임의의 로그인 페이지를 응답을 한다.
        3. 외부 서비스의 로그인 페이지를 성공 시키면 깃허브를 통해서 특정 정보(권한 증서)를 받는데 이를 가지고 깃허브에 인증된 사용자라는 것을 인증할 수 있다.
        4. 깃허브의 `Authorization Server`에 권한 증서를 전달하고 깃허브에 접근할 수 있는 `Access Token`을 전달 받는다.
        5. 깃허브의 Access Token을 이용해서 `Resource Server`에 접근해서 정보를 받을 수 있다. 
    - 이 번 미션에서 깃허브에 요청을 보내서 로그인 페이지를 조회하는 것은 못 하니깐, 깃허브로 받은 `코드`(권한 증서)를 가지고 깃허브에 토큰을 받아 오고 이 것을 통해서 프로필 정보를 가져오는 부분을 검증하는 것을 목표로 한다.
    - 이번 미션에서는 Fake 방식으로 진행해 볼 것이다.
<br>

- ### 인수 테스트와 인증
    - 인수 테스트에서 갑자기 인증?
        - 앞선 단계에서는 고려 하지 않았지만 시나리오에는 ‘누가’라는 정보가 포함되어 있는 경우가 많다.
        - 행위자가 누구인지에 따라 시나리오 흐름과 결과가 달라진다.
    - 인수 테스트에서 인증을 고려할 때 고민해야 할 점
        - 어떤 인증을 이용할 것인가?
        - 인수 테스트에서 인증 정보를 어떻게 포함할 것인가?
        - 인수 테스트에서 로직에서 인증 관련 로직을 어떻게 관리할 것인가?
    - 인증 도구
        - 세션
            
            <img width="700" alt="Untitled93" src="https://user-images.githubusercontent.com/88137420/222066588-aa7b3167-1ced-4d5a-8902-d4eea5f9d1da.png">
            
        - 토큰
            
            <img width="700" alt="Untitled94" src="https://user-images.githubusercontent.com/88137420/222066617-983ac0e3-8eba-4d48-a167-4565571b7b3f.png">
            
        - Oauth
            
            <img width="700" alt="Untitled95" src="https://user-images.githubusercontent.com/88137420/222066668-ec71047f-4b87-440e-8328-64477f04a9bb.png">
            
    - HTTP 인증 프레임워크
        
        <img width="700" alt="Untitled96" src="https://user-images.githubusercontent.com/88137420/222066683-62f0c1cd-cb84-4de4-b805-b12a82d7b7e7.png">
        
        <HTTP 인증 과정 및 예시>
        
        1. 데이터 요청 - ‘즐겨 찾기 목록 요청’과 같이 원하는 데이터를 요청
        2. 인증 요구 - 401 에러 발생 및 유효한 인증 요구(서버가 원하는 인증 스킴 포맷도 함께 전달)
        3. 인증 정보 포함 데이터 요청 - 해당 인증 스킴에 맞는 인증 정보(토큰) 전달  및 데이터 재요청
        4. 데이터 응답 - 토큰을 기준으로 인증을 마치고 원하는 데이터 전달(응답) 
        
    - 인증 스킴
        - Basic
            
            <img width="700" alt="Untitled97" src="https://user-images.githubusercontent.com/88137420/222066704-bd6d0193-4db1-4f4c-8f43-41037e5be2a4.png">
            
            <img width="700" alt="Untitled98" src="https://user-images.githubusercontent.com/88137420/222066721-b9dc7291-cf01-4f61-b873-fe98e0499882.png">
            
        - Bearer - jwt를 통해서 토큰이 만들어짐
            
            <img width="700" alt="Untitled99" src="https://user-images.githubusercontent.com/88137420/222066746-e04ad2eb-07ae-4390-8633-28e5f5417e3e.png">
            
    - 이를 어떻게 테스트로 만들 것인가?
        - RequestSpectification.auth() 뒤에 뭐가 올까?
            - form(email, password)
                
                <img width="700" alt="Untitled991" src="https://user-images.githubusercontent.com/88137420/222066777-203b419f-91ad-484e-92c0-33ce36f2eb91.png">
                
                - form 로그인의 경우 두 번 요청을 보내게 된다.
                - `FormAuthConfig`를 통해서 실제 요청 전에 미리 요청을 보낼 수 있다.
                - 미리 요청을 보내어 세션을 등록하고, 세션 아이디를 쿠키에 담아서 실제 요청을 보낸다.
            - basic(email, password)
                
                <img width="700" alt="Untitled992" src="https://user-images.githubusercontent.com/88137420/222066798-afde163a-5023-40fb-9817-b8fe9fc3cf7f.png">
                
                - `preemptive` : 불 필요한 401 응답과 인증 요청을 줄일 수 있다. / 401 응답을 이미 받았다고 가정하고 basic auth 요청을 보내는 것이다.
            - oauth2(Acceess Token)
                
                <img width="700" alt="Untitled993" src="https://user-images.githubusercontent.com/88137420/222066822-a04ed3bb-3cad-4e99-9fa5-a331fbe61e91.png">
                
                <img width="700" alt="Untitled994" src="https://user-images.githubusercontent.com/88137420/222066838-bf61cbd4-91f0-442c-b813-4ba46baba798.png">
                
                <img width="700" alt="Untitled995" src="https://user-images.githubusercontent.com/88137420/222066856-fe6e2dec-5cef-4f82-956c-c201a9c701e7.png">
                
                <img width="700" alt="Untitled996" src="https://user-images.githubusercontent.com/88137420/222066866-15a8a0ae-ce7a-4d94-a25e-e296bfdc62b9.png">
                
            
<br>

- ### 3주차 미션 Tips
    - 기능 구현이 많지 않을 수 있다.
    - `중요 포인트` : ‘인수 테스트의 조건의 주체(`누가`) 정보를 어떻게 넣으면 인수 테스트를 가독성 좋게 만들 수 있을까?’ 고민 해보면 좋을 것 같다.
    - 인증이라는 행위를 인수 테스트에서 어떻게 할 것인지 1, 2단계 미션을 통해서 연습 해보고 3단계에서 즐겨찾기 기능을 구현을 하시면서 요청을 할 때 토큰을 가지고 요청을 보내고 서버에서는 ‘요청 받은 토큰을 어떻게 처리하고 누구인지를 어디서 정보를 가져와서 처리할지’를 구현 해주시면 된다.
<br>

- ### Q&A
    - 2단계 기능 요구사항 추가 설명
        - 가입 되어 있지 않은 회원의 경우 회원 가입 진행 후에 토큰을 발행
        - 이미 가입이 되어 있는 회원의 경우 바로 토큰을 발행
    - 고아 객체
        - 게시물 - 댓글(게시물 삭제될 때 댓글도 함께 사라져야 한다)
        - 레파지토리에서 테스트가 필요할 것 같다.
<br>
