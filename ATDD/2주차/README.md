- 1주차 미션 리뷰
    - step2 - `시나리오 형태의 요구사항`을 `E2E 테스트`로 기능 구현 해보기
    - step3 - 조금 더 복잡한 요구사항을 시나리오 형태로 만들어보기
    - 스프링 환경에서 테스트 구현이 익숙하지 않으신 분은 학습하는데 시간이 걸리셨을 것이다.
    - 스프링 환경에서 테스트 구현이 익숙하신 분은 ‘어떻게 인수 테스트를 만들지?’, ‘인수 조건을 어떻게 구성할지’ 중점을 맞춰서 개발을 했을 것이라 생각한다.

- Q&A
    - 자바 대신 코틀린을 써도 되나요?
        - 마음 같아서는 사용해도 된다고 하고 싶으나 저를 포함한 많은 분들께서 리뷰를 해주시는거라 이 번 과정에서는 자바로 진행을 해주셨으면 좋겠다.
    - 인수 테스트를 회사에 도입을 하고 싶은데, 어떻게 하는게 좋을까요?
        - 설득하는 과정이 쉽지는 않을 것이다.
        - 입장을 바꿔서 동료 팀원이 내가 `모르는 무언가`를 가져와서 같이 하고자 하면 학습에 대한 부담감과 여러가지 이유로 선뜻 마음이 안갈 것이다.
        - ATDD에 대해서 개인적으로 충분히 경험 해보시고 ‘우리 팀에게 `ATDD`를 잘 적용할 수 있겠다’라는 확신이 들면 프로젝트에 부분적으로 적용 해보면서 팀원들을 설득하는 시간이 필요할 것 같다.
        - 저희 팀 같은 경우에는 운이 좋게도 자바지기님이 리드 하시는 프로젝트에 참여 하다보니 인수 테스트가 이미 갖춰있었다. 하지만 기존의 인수 테스트를 `Cucumber`라는 도구로 적용해본다던지 새로운 방식의 인수테스트를 도입하는 과정은 쉽지 않았다.
    - 인수 테스트를 작성하면서 가독성을 위해서 한글 변수, 메서드를 사용했는데, 단위 테스트에도 적용하는 사례가 있을까요?
        - `목적`을 상기해보면 좋을 것 같다.
        - 요구사항이 `시나리오 형태의 줄 글`로 되어있는 경우가 많고 그러다보니 자연스럽게 가독성적인 측면에서 한글 변수와 메서드를 사용했던 것 같다.
        - 단위 테스트의 경우 검증하고자 하는 대상이 코드레벨의 기능이나 메서드, 클래스가 많다고 느끼는데, 그런 관점에서 ‘한글 변수나 메서드를 사용하는 것이 이점이 있을까?’ 한 번 고민해보시면 좋을 것 같다.
    - 어느정도까지 `Fixture`로 구성하는 것이 좋을까요?
        - 먼저 `Fixture`라 함은 제가 이해하기로 인수 테스트의 메서드를 가리킨다고 이해 했습니다.
        - 제가 이 부분은 인수 테스트의 가독성에 대해서 이야기하면서 다시 다루겠습니다.
    - `RestAssured`가 `MockMVC`와 다르게 컨트롤러부터 하위 레이어까지 전체 로직을 아우르는 `통합 테스트`이다 보니, 큰 프로젝트에 적용하는 것이 어려울꺼라 생각이 드는데, 현업에서는 자주 쓰이고 있나요?
        - 저는 전체 로직을 테스트할 때 RestAssured 테스트를 많이 사용하고 있다.
        - 통합 테스트를 작성하는 주변의 팀들에서는 RestAssured 테스트를 사용한다고 알고 있다.
        - `API 테스트` 목적으로 MockMVC를 써서 `서비스 레이어(비즈니스 레이어)`부터는 `mocking`을 하는 경우를 많이 봤습니다.
    - 개발 스터디를 모을 때 어디서 모으시나요?
        - 왜 먼 곳에서 찾으시나요? 여기 넥스트 스텝 커뮤니티에도 많은 동료가 있습니다.
    
- 1주차 피드백
    - 인수 테스트 격리하기
        - `@Transactional`해서 Rollback 하면 되지 않나?
            - `RANDOM_PORT`, `DEFINED_PORT`를 사용할 경우 `실제 서블릿 환경`이 제공됨(롤백이 적용되지 않음)
            - `톰캣`이 로드가 되면서 `테스트 동작하는 스레드(=RestAssured 메서드가 돌아가는 스레드`)와  `테스트 서버가 뜨는 스레드`가 별로 돌아가기 때문에 트랜잭션이 먹히지 않아서 롤백이 되지 않는다.
        - `@DirtyContext`
            - 효과적인 테스트 수행을 위해서 @DirtyContext를 사용하는 것이 좋지 않다고 생각한다.
            - 스프링에서는 `테스트 컨테이너`를 띄울 때 비용(시간)이 많이 드는 것을 아니깐, 한 번 띄워놓고 띄워놓은 것을 캐싱해서 다른 테스트에서도 재사용할 수 있도록 한다.
            - 이게 무슨 말이냐면, `@SpringbootTest`를 사용하고 있는 여러 개의 클래스가 있다고 가정하고 여러 개의 클래스를 동시에 테스트할 때, 처음 테스트 컨테이너가 로드 되면 이를 재사용한다는 것을 의미한다. → 속도가 빠름
            - 캐싱(재사용)을 못 쓰게 하는 조건 중에 하나가 테스트 컨테이너에 포함된 빈들이 오염될 경우(빈의 상태가 변경된 경우)이고, 더 이상 캐싱을 못 쓰게되기에 새롭게 테스트 컨테이너를 다시 띄워야한다.
            - 이러한 작업을 강제적으로 할 수 있게 하는 것을 `@DitrtiesContext`이라고 한다.
            - 매번 새롭게 컨테이너를 로드 하느라(띄우느라) 비용이 많이 발생한다.(추천하지 않는 이유)
        - @Sql 또는 쿼리 수행
            - 테스트 컨테이너`(컨텍스트)`만 공유(재사용) 하고 테이블은 매번 `truncate` 시키는 방법
            - 프로그램의 복잡성이 올라가면서 테이블이 많아지게 되면 테이블명을 우리가 다 기억하지 못하기 때문에, SQL문을 짤 때 테이블 명을 전부 조회한 결과를 바탕으로 테이블을 truncate 하면 된다.
            - `JPA`의 `EntityManager`를 이용하거나 `DataSource`를 이용해서 테이블 이름을 조회 → 테이블 상태에 의존하지 않는 초기화 환경 구축 가능
            
           ![Untitled](https://user-images.githubusercontent.com/88137420/220135889-5dd4fd37-6ab7-4856-9e7d-a17327735552.png)
            
    - 인수 테스트 리팩토링
        - 테스트의 의도를 명확히 드러내기 → `추상화`
        - 가독성이 왜 중요한가?
            - 테스트가 실패해서 빌드가 되지 않게 된다면, 보통은 테스트를 `@ignore` 혹은 `@Disabled`으로 바꾸기 마련이다.
            - 내가 짠 코드라면 그대로 변경할 마음이라도 생길텐데, 내가 짜지 않은 코드`(의도를 알 수 없는 테스트)`까지 수정을 해야한다면 더더욱이나 테스트 코드가 방치가 되기 쉬워진다.
            - 이러한 이유로 프로덕션 코드의 가독성만큼이나 테스트 코드의 가독성도 중요하다.
        - 테스트 코드 중복 제거
            - 자주 사용되는 코드는 메서드로 분리해서 재사용
            - `CRUD 추상화`(RestAssured 및 부수적인 작업) - 하나의 RestAssured 메서드를 만들고, 들어가는 변수로 ‘CRUD’를 작업을 할 수 있도록 만들기
            - `Cucumber`나 `JBehave`와 같은 `BDD` 도구 사용 - 학습 비용은 들지만 가독성인 측면에서는 큰 도움이 됨
        - 의도를 확실하게 드러내기 위해서 한글 메서드, 변수 사용
            - 컨벤션에 대한 고민들은 팀원들과 협의가 필요하다.
        - static 메서드만 있는 클래스를 분리
            - 자주 사용하지만 클래스 생성이 번거롭다면, 이 모두를 묶어서 static 메서드가 있는 클래스로 분리

- 미션 추가 설명 및 관련 질문
    - 도메인 : 지하철 역 / 지하철 구간 / 지하철 노선
    - Q&A
        - TRUNCATE 격리할 때 테이블의 ID 컬럼명(STATION_ID, LINE_ID, …)을 다르게 설정할 경우 오류나지 않나요!?
            - `AutoIncrement`를 초기화 하는 경우는 없더라도 에러가 나진 않는다.
            - (자문자답) 아까 TRUNCATE 관련 이슈 전 처음에 브라운 강사님 코드대로 TRUNCATE 했다가 ID 컬럼명이 달라서 오류가 나서 아래같이 해결했어요!
                - 1. ALTER TABLE ... ID RESTART WITH 1 문 제거
                - 2-1. dialect를 H2 database 사용 시 pk 초기화를 하려면 TRUNCATE 명령문에 RESTART IDENTITY를 추가하는 방법]entityManager.createNativeQuery("TRUNCATE TABLE " + tableName + " RESTART IDENTITY").executeUpdate();
                - 2-2. dialect를 MySQL 사용 시 TRUNCATE 진행 시 별다른 명령문이 없어도 AUTO_INCREMENT가 재설정 됨(5.7, 8.0 동일)entityManager.createNativeQuery("TRUNCATE TABLE " + tableName).executeUpdate();
        - 외래키가 있을경우 Truncate시 에러가 발생하지 않나요?
            - `SET REFERNTIAL_INTEGRITY FALSE` 조건으로 일단은 문제 없이 프로젝트를 진행 했는데 한 번 확인 해봐야겠다.

- 2주차 미션 - ATDD + TDD
    - ‘인수 테스트 이후에 어떻게 하면 TDD를 수월하게 할 수 있을지?’에 대한 내용을 다루고 있다.
    - 단위 테스트
        - 단위 테스트의 개념이 모두 다를 것이다.
        - 누구는 단위 테스트를 메서드 레벨, 클래스 레벨 혹은 누구는 작은 기능의 레벨로 작성하는데, 그러면 이 단위 테스트의 기준이 뭘까? 한 번 고민 해봐야한다.
        - 공통된 생각`(암묵적 동의)` : 작은 코드 조각을 검증 / 빠르게 수행 가능 / `격리`된 방식으로 처리
        - 두 단위 테스트의 차이?
            
            ![Untitled](https://user-images.githubusercontent.com/88137420/220136007-c04dd547-eb50-4eae-94a2-4964eb68f1c6.png)
            
            - 두 번째 테스트 - Station이 실패하면 Line이 실패할 수도 있다.
            - 협력 객체의 유무`(테스트하는 대상이 의존하고 있는(필요로 하는) 대상이 있느냐? 없느냐?)`
        - `통합` vs `고립`
            - **김아무개 曰**
                - 협력 객체의 실패로 인해서 테스트 하고자 하는 대상이 실패하면 안된다!
                - 협력 객체를 가짜로 들고 와서 여기에서 실패는 만들지 말자!
                - 이를 `Solitary Tests(고립 단위 테스트)`라고 한다!
                - Mock을 주로 이용한다!
            - **박아무개 曰**
                - 에이 그래도 실제 객체가 있는데 그걸 이용해서 테스트 해야지?
                - 이를 `Sociable Tests(통합 단위 테스트)`라고 한다!
            
            ![Untitled](https://user-images.githubusercontent.com/88137420/220136081-e481bad3-2733-4ec2-a326-3e56c3e871b5.png)
            
        - `테스트 더블`
            - **우아무개 曰**
                - 가짜 객체를 이용하겠다는건 알겠는데 그걸 어떻게 해?
                - 이런 질문을 한다면 테스트 더블에 대한 개념을 알아야 한다.
                - `고립된 협력 객체`를 만들기 위한 방식이 많은데 그 중에 하나가 `Test Double`이다.
                - `가짜 객체(고립된 협력 객체)`를 만드는 방법이 많은데, 하단을 참조하면 된다.
            
            ![Untitled](https://user-images.githubusercontent.com/88137420/220136254-1adb9968-42cc-4b54-a0d0-97b69553cde7.png)
            
            - `Stub`  : 협력 객체를 직접 만들 때, 협력 객체의 메서드에 대한 호출 값을 미리 지정하는 방법
                - 이 때, 사용 `Mockito`를 사용할 수 있다.
                - `MockitoExtension`을 사용하면 `@Mock`, `@injectmocks`을 사용할 수 있다.
                - `SpringBean`을 stubbing하고 싶다면(이미 컨테이너에 올라가있는 빈을 사용 하고 싶다면), `SpringExtention`을 사용해서 `@MockBean`을 사용할 수 있다.
                - 협력 객체가 잘 동작하던지 안하던지 상관하지 않고 테스트하고자 하는 대상이 잘 동작하는지만 확인하는 것이다.
            - `Fake`  : 가짜 객체를 직접 새로 생성하는 방법이다.
                - stub방식은 ‘Mockito’와 같은 라이브러리를 이용해서 가짜 객체를 만들어서 테스트를 사용하는 것이지만, fake방식은 가짜 객체가 아닌 테스트를 위한 다른 객체를 직접 만들어서 사용하는 것이다.
                
                ![Untitled](https://user-images.githubusercontent.com/88137420/220136332-a56cf714-06a1-477c-ac4b-6da8cc753706.png)
                
                - DAO의 메서드가 호출이 되면 DB의 값을 조회해서 요청한 응답 값을 전해주는데, Fake방식은 FakeDAO 객체를 주입을 해서 DB와 비슷하게 `HashMap`에 있는 값을 응답하게끔 한다.
            - Mock
                - mock방식은 stub 방식 같이 단순하게 메서드가 호출되었을 때의 응답 값을 지정해주는게 아니라 호출되었는지 안 되었는지 확인을 위해서 확인할 수 있다.
                - 즉, 상태를 검증 한다면 stub방식을 사용하지만, 호출 여부를 확인하기 위해서는 mock방식을 사용한다.
            - 심화
                - Mock을 사용해서 객체를 생성하고 객체를 까보게 되면 객체가 아니라 객체라는 인터페이스를 상속 받은 다른 객체가 나온다.
                - 이 객체에는 특정 메서드가 얼마나 호출 되었는지 알 수 있는 count 변수가 있는데, 이를 이용해서 호출여부를 확인할 수 있다.
                - stub보다 mock이 더 테스트를 자세하게 해준다고 알면 될까요? → No
                    - 검증하는 방식이 다른 것이다.
                    
                    ![Untitled](https://user-images.githubusercontent.com/88137420/220136423-9462b5c6-685a-4cf1-a951-5aae21438154.png)
                    
                    - 예를 들어서 위의 SecurityCentral(파란색)이 Window객체와 Door객체를 의존하고 있는데, 이 때 Window와 Door를 목 객체로 주입 받아 생성을 하게 된다면 Window객체의 close 메서드와 Door객체의 close 메서드가 얼마나 호출 되었는지 확인할 수 있다.
                    - stub은 호출되는 메서드를 지정해줘야 하는데 mock은 그럴 필요가 없다!
                    - 왜냐하면 호출 됐는지 안 됐는지만 확인할 것이라 그렇다.
            - 정리
                - `stubbing`과 `mocking`이 있는데 이는 테스트하는 방식이다.
                - mocking을 해서 테스트를 구현할 때 협력 객체는 `mock`객체이다.
                - stubbing을 해서 테스트를 구현할 때 협력 객체는 `stub`객체이다.
                - mocking을 사용할 때, 메서드에 대한 행위를 따로 지정해주지 않으면 NPE(NullPointException)이 발생하진 않나요? → 발생하지 않음
                - stub객체를 만들 때도 mock이라는 메서드를 사용하고 mock객체를 만들 때도 mock이라는 메서드를 사용해서 혼란스러운 경우가 생긴다.
                - `TestDouble`객체를 만들기  위해서 사용하는 것이 mock 메서드이다. 따라서 mock메서드는 mocking도 할 수 있고 stubbing도 할 수 있다.
                - 즉, stub은 지정한 값을 검증하는 테스트를 진행하는 것이고, mock은 호출여부 및 횟수를 검증하는 테스트를 진행하는 것이다.
                - `MockitoExtenstion`은 스프링과 아무련 관련이 없다. 모키토 자체의 컨테이너를 만든다고 생각하면 될 것 같다. 모키토 자체의 컨테이너에 @Mock 객체를 만들어서 주입을 해준다.
                - 아무래도 stub방식으로 테스트를 진행하게 되면 디버깅했을 때 어떤 값이 리턴되었는지 알 수 있어서 테스트하기 수월하다고 느낀다.(개인적 생각)
                - mocking은 협력 객체가 어떤 행위를 했냐? 안 했냐?를 판단하는데 사용하고, stubbing은 협력 객체의 값이 필요할 때 사용한다.(아주 깔끔한 정리)
                - Mockito에서 사용하는 mock은 mock객체이면서 stub객체이다.
                - 우리 미션에서는 `stubbing`만 다룰 것이다.
                - (질문) 저는 최대한 도메인 쪽에 비즈니스 로직을 집약해서 Stub 없이 TDD를 구현하려 했는데 이건 안될까요? 서비스 로직이 그렇게 복잡하지 않으면 굳이 가짜 객체를 이용하지 않아도 충분히 테스트가 될거 같아서요. → 맞습니다. 제가 말하는 것은 ‘stub방식을 꼭 해야한다’는 것이 아니라 ‘협력 객체를 이용할 때는 TestDouble을 사용해야한다.’라는 것을 이야기한 것이구요.
        - 가짜 객체 vs 실제 객체
            - 가짜 객체(테스트 더블)의 장, 단점
                
                ![Untitled](https://user-images.githubusercontent.com/88137420/220136517-0856ee29-3ddb-4ed5-834a-a2aab22a1e12.png)
                
            - 실제 객체의 장, 단점
                
                ![Untitled](https://user-images.githubusercontent.com/88137420/220136564-a931025c-2f84-4f97-95bf-8e1e728aed8a.png)
                
            - `가짜 객체`를 활용하면 `실제 객체`를 사용할 때보다 조금 `더 편하게` 테스트를 작성할 수 있다.
            - 하지만 상세 구현에 의존하는 테스트가 될 수 있다.
            - 결론 : TDD를 연습할 때는 가급적이면 실제 객체를 활용하는 것을 우선으로 진행하나 테스트 작성이 어렵거나 흐름이 잘 이어지지 않는다면 테스트 더블을 활용하는 방법으로 하는 것을 추천합니다.
            
        - 잠깐!? 단위 테스트 ? 통합 테스트 ?
            
            ![Untitled](https://user-images.githubusercontent.com/88137420/220136645-98dbc695-29dd-4434-821d-9e162d232ce2.png)
            
            ![Untitled](https://user-images.githubusercontent.com/88137420/220136696-21e06428-8386-4fa0-a513-6c9ad5d21453.png)   
            
        - Classist vs Mockist
            
            ![Untitled](https://user-images.githubusercontent.com/88137420/220136795-8f6c2c5d-eda5-4c92-96c8-85712389937f.png)
            
            - Mockist : 테스트 대상을 위해서 협력 객체마저도 격리가 필요하다. 즉, 테스트 대상이 의존 하는 대상(협력 객체)를 가짜 객체(테스트 더블)로 만들어야한다.
            - Classist : 굳이 그럴 필요까지 있냐? 테스트를 격리해야하는 대상은 코드가 아니라 또 다른 테스트다. 즉, 테스트 간 공유하는 의존성이 아니라면 실제 객체를 사용해도 된다.
            - (의견) mock은 프로덕션에 리팩토링이 들어가게 되면 테스트 또한 변경해야하는 단점이 생겨서 실제 객체를 사용해서 테스트를 하는게 좋은거 같다.
    - TDD
        - TDD Approach(`Outside In` vs `Inside Out`)
            
            ![Untitled](https://user-images.githubusercontent.com/88137420/220136850-6d2e6793-6e60-4f30-beda-981416bf6e09.png)
            
            - Outside In
                - 상위 레벨 테스트부터 시작 (컨트롤러 → 서비스 → 도메인)
                - 테스트 더블을 활용하여 테스트 대상이 의존하는 협력 객체의 `예상 결과`를 정의
            - Inside Out
                - 실제 객체를 다뤄야 하기 때문에 도메인 모델으로 시작
                - 의존하는 협력 객체가 실제로 존재해야지 테스트를 작성할 수 있다.8
        - Driving TDD in ATDD
            - Outside In
                - `OOP`와 `TDD`가 익숙하지 않은 사람들에게 가이드할 때 도움이 된다고 생각한다.
                - 도메인에 대한 이해도가 높지 않은 상태에서도 진행이 가능하다.
                - 상대적으로 프로덕션 코드에 의존적인 테스트가 작성된다(깨지기 쉬운 테스트) → 프로덕션 코드의 로직이 바뀌게 되면 테스트 더블의 return값도 바꿔줘야 한다.
            - Inside Out
                - 도메인 설계가 충분히 이루어진 다음에만 진행이 가능하다.
                - TDD 사이클을 이어 나가기가 상대적으로 어렵다.
                - 프로덕션 코드에 덜 의존적인 테스트가 작성된다.
            - 둘 중에 하나를 선택 해야하는 문제는 아니다.
        - 무엇을 기준으로 TDD를 해야할까?
            
            ![Untitled](https://user-images.githubusercontent.com/88137420/220136916-2d843246-07cf-4b1c-8b56-3c3c65c435b0.png)
            
            - 추천 방법
                - BDD나 ATDD에서는 Outside In 방식으로 하는 것을 많이들 추천한다.
                - 하지만, 저는 관리하기 수월한 테스트를 지향하기 때문에 ‘Outside In’과 ‘Inside Out’을 혼합하여 사용한다.
                - Top-Down으로 방향을 잡고, Bottom-Up으로 구현한다.
                - 인수 테스트 작성을 통해 요구사항과 기능 전반에 대한 이해를 가진다.
                - 이 때, 내부 구현에 대한 설계의 흐름을 구상한다.
                - 설계가 끝이 나면 도메인부터 차근차근 TDD로 기능을 구현한다.
                - 만약, 도메인이 복잡하거나 설계가 어려울 경우에는 이해하고 있는 부분부터 차근차근 기능을 구현하면 된다.

- 2주차 미션 소개
    - 실습 : 구간 단위 테스트, 구간 서비스 단위 테스트, 구간 서비스 테스트(+ Mock) + 리팩토링(비지니스 로직을 도메인의 영역으로 옮기기)
    - 1주차 : 지하철 구간 삽입 개선(처음, 중간, 끝에 들어갈 수 있음 + 예외 케이스)
    - 2주차 : 지하철 구간 삭제 개선
    - 3주차 : 조금 어려울 수 있음 / 최단 경로를 조회하는 기능(외부의 다익스트라 라이브러리를 이용) / Outside In + Inside Out을 적절히 사용하기
