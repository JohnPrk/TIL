# 인덱스

<br />

### 인덱스를 사용하는 이유

- 한 개의 테이블에 `백 만개의 데이터`가 존재할 때 `where 조건문`이나 `join 조건문`으로 `특정한 결과`를 조회 하려고 할 때 일반적으로 걸리는 시간은 $O(N)$이라고 할 수 있습니다.
- 이 과정에서는 모든 값이 조건에 맞는지 전부 `스캔`해야하기 때문에 `Full Scan`(혹은 `Table Scan`)이라고 합니다.
- 하지만, 조건문에 해당하는 열을 `B-Tree 기반 인덱스`로 사용하면 $O(logN)$의 시간으로 줄일 수 있다는 특징이 있습니다.
- 즉, 인덱스는 `관계형 데이터베이스`(RDBMS)에서 `검색 작업`의 성능을 향상시키는 데 사용된다고 할 수 있습니다.

<br />

### 인덱스

- `MySQL`에서 인덱스는 `key-value` 자료 구조의 형태라고 볼 수 있습니다.
- 여기에서 `key`는 인덱싱된 열의 값을 나타내고, `value`는 실제 테이블의 위치를 가리킵니다.
- `MySQL`의 경우 `테이블 데이터`와 `인덱스`는 `단일 테이블스페이스` 내에 함께 저장됩니다.
- `MySQL`에서 테이블에 대해서 `쿼리`할 때, `옵티마이저`는 쿼리와 사용 가능한 인덱스를 기반으로 사용할 가장 적합한 인덱스를 자동으로 선택합니다.
- 즉, 쿼리가 실행되면 `MySQL`은 인덱싱된 열에서 지정된 값에 대한 인덱스를 검색한 다음 테이블에서 해당 행을 검색합니다.
- 이러한 프로세스를 `쿼리 최적화`라고 합니다.

<br />

### 이진 탐색

- 일반적으로 B-Tree 형태의 인덱스는 이진 탐색 알고리즘을 통해서 데이터를 탐색합니다.
- 이진 탐색은 정렬된 배열에서 특정 요소를 검색하는 데 사용되는 효율적인 알고리즘이라고 할 수 있습니다.
- 이진 탐색은 배열의 전체 크기를 절반의 위치에서 대상을 찾고
    - 대상이 없고 검색할 데이터의 크기가 크다면 오른쪽에서 재귀적으로 작업을 수행하고,
    - 대상이 없고 검색할 데이터의 크기가 작다면 왼쪽에서 재귀적으로 작업을 수행하고,
    - 절반의 위치에서 대상을 찾게 되면 탐색이 종료됩니다.
- 이러한 과정은 탐색해야할 범위를 거의 절반씩 줄이는게 되기 때문에 효율적이라고 할 수 있고, 시간 복잡도는 $O(log N)$라고 할 수 있습니다.

<br />

### 주의사항

- 인덱스는 인덱싱된 열의 값(key)과 실제 테이블 위치(value)를 저장하기 위해 별도의 데이터 구조를 생성하므로 추가 저장 공간이 필요합니다.
- 즉, 테이블에 인덱스가 많을수록 더 많은 저장 공간이 필요하다고 할 수 있습니다.
- B-Tree 구조의 특성상 데이터가 삽입, 수정, 삭제될 때마다 정렬된 데이터에서 데이터가 삽입될 위치를 탐색하는 추가적인 비용이 들게 됩니다.
- 또한, 인덱스가 위치한 테이블의 데이터가 써질(`write`-`삽입`, `수정`, `삭제`) 때마다 인덱스를 업데이트 해야 하는 추가적인 오버헤드가 발생합니다.

 
<br />

### *<참고자료>*

- [DB 인덱스(DB index) !! 핵심만 모아서 설명합니다 !! (31분이 아깝지 않을 겁니다)](https://www.youtube.com/watch?v=IMDH4iAQ6zM&list=PLcXyemr8ZeoREWGhhZi5FZs6cvymjIBVe&index=25)

<br />
