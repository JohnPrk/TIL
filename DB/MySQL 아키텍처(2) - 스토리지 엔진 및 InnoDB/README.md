# MySQL 엔진 아키텍처(2) - 스토리지 엔진 및 InnoDB
<br>

### 스토리지 엔진

- `스토리지 엔진`은 데이터 저장 및 검색, 트랜잭션 관리, 인덱싱 등과 같은 다양한 작업을 수행하는 주체라고 할 수 있습니다.
- 이러한 `작업` 및 `세부 구현 부분`은 사실 스토리지 엔진에 의해 결정 되어지는데,
- 하나의 스토리지 엔진이 모든 작업을 처리하기 보다는 기능에 따라 다양한 스토리지 엔진으로 나누어집니다.
- 이를 통해서 회사는 이러한 스토리지 엔진을 자신의 데이터 처리 방식에 따라서 커스텀화하거나 자신이 원하는 스토리지 엔진을 개발할 수 있다는 특징을 가지고 있고,
- MySQL 같은 경우에는 하나의 MySQL 엔진이 여러 개의 스토리지 엔진을 사용하는 방식인 플러그인 방식을 사용하고 있습니다.
<br>

### 플러스인 스토리지 엔진

- 플러그인 스토리지 엔진은 개발자가 런타임에 동적으로 실행할 수 있는 사용자 정의 스토리지 엔진을 생성할 수 있는 인터페이스를 제공합니다.
- 플러그인 스토리지 엔진은 스토리지 엔진을 `독립적`으로 개발하거나 커스텀화 할 수 있고 이를 통해 `확장성`과 `유연성`의 장점을 가질 수 있습니다.
- MySQL 같은 경우에는 ‘SHOW ENGINES’ 명령어를 통해서 자신의 스토리지 엔진을 확인할 수 있습니다.

<img width="700" alt="image" src="https://user-images.githubusercontent.com/88137420/229975110-931ba171-9db1-4afe-83f7-8f2f065cd77b.png">

- 여기에서 Support라는 MySQL 엔진과 각 스토리지 엔진의 `연결 여부`를 나타내고 있습니다.
    - YES : MySQL 서버에 해당 스토리지 엔진이 포함되어 있고 사용가능으로 활성
    - DEFAULT : ‘YES’와 동일한 상태이지만, 필수 스토리지 엔진(없으면 실행X)
    - NO : MySQL 서버에 포함되지 않았음을 의미
<br>

### InnoDB 스토리지 엔진

- Inno DB 스토리지 엔진은 MySQL 8.0 버전의 필수이자 기본 스토리지 엔진입니다.
- InnoDB는 MySQL의 `RDBMS`(관계형 데이터베이스 관리 시스템) 부분에 초점을 맞춘 스토리지 엔진입니다.
- Inno DB의 개략적인 구조는 다음과 같습니다.
    
    <img width="700" alt="image1" src="https://user-images.githubusercontent.com/88137420/229975146-7b7e16ff-304b-4a2c-af9b-63d511d6b381.png">
    
<br>

### InnoDB 스토리지 엔진의 특징

- `PK 키에 의한 클러스트링`
    - InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스트링되어 저장됩니다.
    - 쉽게 이야기하자면, PK 값의 순서대로 디스크에 저장된다는 것을 의미합니다.
- `외래 키 지원`
    - Foreign Key 를 사용할 수 있습니다.
- `MVCC`(Multi Version Concurrency Control)
    - MVCC은 다중 사용자 환경에서 동시성을 관리하고 데이터 일관성을 보장하는데 사용되어집니다.
    - MVCC의 큰 목적은 잠금(락킹)을 사용하지 않고 일관된 읽기를 제공하는 데 있습니다.
    - InnoDB는 `언두 로그`(Undo Log)를 이용하여 이 기능을 구현합니다.
- `잠금 없는 일관된 읽기`(Non-Locking Consistent Read)
    - 격리 수준이 `SERIALIZABLE`이 아닌 `READ_UNCOMMITTED`, `READ_COMMITTED`인 경우 INSERT와 연결되지 않는 순수한 읽기 작업은 다른 트랜잭션의 변경과 관계없이 바로 실행합니다.
        
        <img width="700" alt="image2" src="https://user-images.githubusercontent.com/88137420/229975183-d8604ffc-5efd-4618-b9e1-3e43aea70b33.png">
        
- `자동 데드락 감지`
    - InnoDB 스토리지 엔진은 내부적으로 자금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리합니다.
    - InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 주기적으로 잠김 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션 중 하나를 강제 종료합니다.
    - 이 때, 어느 트랜잭션을 종료할 것인지를 판단하는 기준은 트랜잭션의 언두 로그의 양이며, 언두 로그 레코드를 작게 가진 트랜잭션이 일반적으로 종료 및 롤백 대상이 됨을 의미합니다.
- `자동화된 장애 복구`
    - InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 메커니즘이 탑재되어 있습니다.
    - 이러한 매커니즘을 이용해서 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행됩니다.
- `InnoDB 버퍼 풀`
    - InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간입니다.
    - 이를 통해 디스크 I/O를 줄이고 자주 액세스하는 데이터를 빠르게 반환하는 데 사용됩니다.
    - 또한, 이 과정에서 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 할 수 있습니다.
    - MySQL 5.7 버전부터는 InnoDB의 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선이 되었는데,
    - 일반적으로 50%정도의 메모리 공간을 버퍼 풀에 할당하고 나머지를 MySQL 서버와 운영체제에게 할당하는 것이 좋다고 합니다.
    - InnoDB 버퍼 풀은 `LRU`(Least Recently Used)와 `MRU`(Most Recently Used)의 리스트의 형태로 구성되어 있습니다.
        - 이 때, LRU는 오래된 메모리 영역에, MRU는 새로운 메모리 영역에 적용되는 알고리즘입니다.
            
            <img width="700" alt="image3" src="https://user-images.githubusercontent.com/88137420/229975212-97db7043-c152-440d-b6dc-3892becef638.png">
    
    - InnoDB의 버퍼 풀은 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라집니다.
    - 하지만, 버퍼 풀의 메모리 공간은 단순히 캐시 기능의 향상만을 위함이지 버퍼 기능까지 향상 시키려면 `리두 로그`(Redo Log)를 사용해야합니다.
    - InnoDB 버퍼 풀 속에 `데이터 페이지 버퍼`는 상태 변화가 없는 `클린 페이지`와 INSERT, UPDATE, DELETE 명령으로 변경하고자 하는 `더티 페이지`로 이뤄져 있습니다.
    - 트랜잭션을 통해 버퍼 풀의 데이터를 수정하면 변경사항이 `프라이빗 리두 로그 버퍼`에 기록됩니다.
    - 프라이빗 로그 버퍼는 디스크의 `리두 로그 파일`에 기록되기 전에 트랜잭션에 의해 변경된 사항을 임시로 저장하는 데 사용됩니다.
    - 트랜잭션이 커밋되면 트랜잭션에 대한 리두 로그 항목이 디스크의 리두 로그 파일에 기록되지만, 이는 상황에 따라서 일정 시간동안 미뤄질 수 있습니다.
    - InnoDB 스토리지 엔진에서 더티 페이지를 디스크로 동기화하는 스레드를 `클리너 스레드`라고 하는데,
    - 일반적으로 이러한 작업은 리두 로그 버퍼의 크기의 일정 수준까지 기다렸다가 클리너 스레드를 통해서 한 번에 처리함(`버퍼링`)으로써 여러 번의 디스크 쓰기를 한 번으로 줄이게 됩니다.
    - 요즘에는 어댑티브 플러시 기능을 통해서 리두 로그 버퍼의 속도에 맞춰서 클리너 스레드가 작동하게 됩니다.    
    
```java
    🍊 InnoDB 스토리지 엔진에서 데이터를 찾는 과정
    
    1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
    2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
    3. LRU 리스트에 위치한 데이터가 실제로 읽히면 MRU 헤더 부분으로 이동
    4. 버퍼 풀에 상주하는 데이터 페이지는 사용자가 얼마나 최근에 요청했는지에 따라서 나이(age)가 부여되고, 오랫동안 사용되지 않으면 버퍼 풀에서 삭제되어집니다.
    5. 필요한 데이터가 자주 요청되었다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가 
```
  
- `Double Write Buffer`
    - InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록합니다.
    - 하지만, 더티 페이지에서 디스크 파일로 `플러시`할 때 일부만 기록되면 안되기 때문에 Double-Write 기법을 사용합니다.
    - 더블 라이트 버퍼는 시스템 오류가 발생한 경우에도 데이터 무결성을 보장하는 방식으로,
    - 페이지가 이중 쓰기 버퍼에 기록되면 전체 페이지가 연속 디스크 공간 블록에 두 번 기록됩니다.
    - 이렇게 하면 시스템 오류로 인해 쓰기 중 하나가 손상되거나 손실된 경우 다른 쓰기를 사용하여 데이터를 복구할 수 있습니다.
- `언두 로그`
    - InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보자아기 위해 변경되기 이전의 데이터를 별도로 백업하고 이를 언두 로그라고 합니다.
    - 언두 로그는 크게 트랜잭션 보장과 격리 수준 보장, 이 두 가지의 역할을 하게 됩니다.
        - 트랜잭션 보장은 트랜잭션이 롤백이 되면 변경된 데이터를 복구하는데 사용하는 것을 의미합니다.
        - 격리 수준 보장은 데이터 변경 중에도 읽기 요청이 오면 언두 로그를 통해서 데이터를 반환하는 것을 의미합니다.
    - 하지만, 대용량의 데이터를 처리하는 트랜잭션 중에는 언두 로그가 급격히 증가해서 언두 로그 버퍼의 크기를 넘는 문제가 생길 수 있는데, 현재 MySQL 버전에서 언두 로그 버퍼의 크기를 동적으로 할당하면서 해결하고 있습니다.
- `체인지 버퍼`
    - RDBMS에서 레코드가 INSERT되거나 UPDATE될 때는 데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트 하는 작업도 필요합니다.
    - 이러한 인덱스가 디스크에서 가져오지 않고 버퍼 풀에서 빠르게 사용하고자 인덱스를 모아둔 임시 메모리 공간을 체인지 버퍼라고 합니다.
- `리두 로그 및 로그 버퍼`
    - 리두 로그는 트랜잭션의 4가지 요소인 ACID에서 D(Durable)에 해당하는 속성과 가장 밀접하게 연관되어 있습니다.
    - 리두 로그는 하드웨어나 소프트웨어 등의 여러 가지 문제로 인해 MySQL 서버가 비정상적으로 종료될 때 기록되지 못한 데이터를 잃지 않게끔 작동하게 됩니다.
    - MySQL 비정상적으로 종료되는 경우 InnoDB 스토리지 엔진은 두 가지의 문제가 되는 데이터를 가질 수 있습니다.
        - 커밋되었지만 디스크에 기록되지 못한 데이터
        - 롤백되었지만 디스크에 이미 기록된 데이터
        - 전자의 경우 리두 로그에 저장된 데이터를 다시 복사해서 사용해서 해결할 수 있고,
        - 후자의 경우 언두 로그를 사용해서 해결할 수 있는데, 이 과정에서 리두 로그에서 변경사항에 대한 메타 데이터를 확인해야 합니다.
- `어댑티브 해시 인덱스`
    - 일반적으로 인덱스라고 하면 이는 테이블에 사용자가 생성해둔 `B-Tree 인덱스`를 의미합니다.
    - 하지만, 여기에서 언급하는 어댑티브 해시 인덱스는 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 자주 요청하는 데이터에 대해서 자동으로 생성하는 인덱스 입니다.
    - 어댑티브 해시 인덱스는 key-value 형태로 이루어져있어서 원하는 페이지를 즉시 찾을 수 있습니다.

<br>
