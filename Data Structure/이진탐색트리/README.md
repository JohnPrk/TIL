# 이진탐색트리

<br />

### 배열과 연결 리스트

- 이진탐색트리를 알아보기에 앞서서 `배열`과 `연결 리스트`는 여러 개의 데이터를 저장하고 사용할 때 일반적으로 사용하는 자료구조입니다.
- `배열`과 `연결 리스트`는 `정렬 여부`에 따라서 `시간 복잡도`가 조금 다를 수 있는데, 이를 정리해보자면 아래와 같습니다.
    
    <img width="700" alt="image" src="https://user-images.githubusercontent.com/88137420/233770260-f1ee3fa6-98c0-4180-8829-3cef0412a1d3.png">

    
- 배열과 연결 리스트가 일반적으로 자주 사용하는 자료구조이지만, 배열과 연결 리스트 모두 특정한 작업에 대해서 $O(N)$의 시간 복잡도를 가지기 때문에 `데이터의 개수`에 크게 영향을 받는다는 문제점을 가지고 있습니다.
- 이러한 부분을 해결하기 위해 이진탐색트리를 사용할 수 있습니다.

<br />

### 이진탐색트리

- `이진탐색트리`(Binary Search Tree)를 정의해보자면 `이진 트리`의 자료구조 형태에서 특정한 자식 노드의 규칙이 있는 자료구조가 할 수 있을 것 같습니다.
- 이러한 이진탐색트리를 사용하면 `결론적`으로는 삽입, 검색, 삭제 연산을 최대 $O(logN)$의 시간으로 처리할 수 있다는 장점을 가지고 있습니다.
- 먼저 이진트리라는 것은 각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 형태의 자료구조이고, 각 `노드`와 `엣지`는 `연결 리스트`로 구현할 수 있습니다.
- 이 때, 자식 노드의 규칙은 다음과 같습니다.
    - `왼쪽 자식 노드`는 `부모 노드`보다 작습니다.
    - `오른쪽 자식 노드`는 `부모의 노드`보다 큽니다.
- 일반적인 이진탐색트리는 다음과 같이 표현할 수 있습니다.
    
    <img width="700" alt="image1" src="https://user-images.githubusercontent.com/88137420/233770266-8670b8cb-dbc4-4ced-afd1-10e977bffab1.png">

    
<br />

### 이진탐색트리의 탐색 과정

- 이진탐색트리 내에 존재하는 어떠한 데이터를 탐색한다고 가정해보겠습니다.
- 먼저 `루트 노드`부터 시작해서 `찾으려는 값`과 `노드의 값`을 `비교`하고
    - 비교한 결과가 작다면 `왼쪽 자식 노드`로 이동하고
    - 비교한 결과가 크다면 `오른쪽 자식 노드`로 이동하고
    - 비교한 결과가 같다면 `데이터 탐색`이 `완료`됩니다.
- 이러한 `분기 처리`를 데이터 탐색이 완료될 때까지 `재귀적`으로 수행합니다.
- 이러한 과정에서 한 쪽으로 치우쳐 있는 트리 구조(`Skewed Tree`)가 아닌 이상, 탐색을 할 때마다 비교해야 할 노드들이 `거의 절반씩` 사라지기 때문에 효과적이라고 할 수 있습니다.
- 그리고 탐색 과정은 부모 노드에서 자식 노드로 이어지기 때문에, 탐색 과정에 대한 시간 복잡도 `트리의 높이`와 `비례`한다는 것을 알 수 있습니다.
- 즉, `데이터의 개수`가 `N개`라면,
    - 균형잡힌 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(logN)$입니다.
    - 편향된 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(N)$입니다.
- 이 과정에서는 트리의 구조가 변경되지 않습니다.

<br />

### 이진탐색트리의 삽입 과정

- 이진탐색트리에 새로운 데이터를 삽일 할 때 노드가 들어갈 위치를 먼저 탐색하는 과정이 필요합니다.
- 먼저 이진탐색트리에서 새로운 데이터가 삽입되더라도 기존의 트리구조가 변경되지 않는다는 특성을 가지고 있습니다.
- 이진탐색트리 내에 존재하지 않는 어떠한 데이터를 삽입한다고 가정해보겠습니다.
- 먼저 `루드 노드`부터 시작해서 `삽입할 값`과 `노드의 값`을 `비교`하고
    - 비교한 결과가 작다면 `왼쪽 자식 노드`로 이동하고
    - 비교한 결과가 크다면 `오른쪽 자식 노드`로 이동합니다.
    - 이 때, 자식 노드가 존재하지 않으면 그 위치에 새로운 데이터를 삽입합니다.
- 삽입 과정은 탐색 과정가 거의 동일하기 때문에 트리의 높이가 높아질수록 탐색해야할 노드들이 거의 절반씩 사라진다는 것을 알 수 있습니다.
- 따라서 `삽입 연산`의 `시간 복잡도` 역시 트리의 높이에 비례하게 됩니다.
- 즉, `데이터의 개수`가 `N개`라면,
    - 균형잡힌 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(logN)$입니다.
    - 편향된 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(N)$입니다.
- 이 과정에서는 트리의 구조가 변경되지 않습니다.

<br />

### 이진탐색트리 삭제 과정

- 삭제 과정은 삽입이나 탐색 과정과는 다르게, 기존의 트리구조의 변경이 있을 수 있기 때문에 많이 `복잡`하다고 할 수 있습니다.
- 삭제 연산도 삽입 연산과 마찬가지로 삭제할 노드를 찾기 위한 탐색의 과정이 필요합니다.
- 삭제 연산에서의 경우는 3가지의 경우를 나눠서 생각해봐야 합니다.
    - `삭제하려는 노드`가 `마지막 노드(= 자식 노드 X)`일 경우
    - `삭제하려는 노드`가 `왼쪽`이나 `오른쪽` 중 하나의 `자식 트리`만 가지고 있는 경우
    - `삭제하려는 노드`가 두 개의 자식 트리 `모두` 가지고 있을 경우

<br />

### 삭제하려는 노드가 마지막 노드일 경우

- 삭제하려는 노드가 마지막 노드일 경우는 삭제할 노드가 존재하는 위치까지 탐색한 후에 `부모노드`에서 `삭제할 노드`의 `연결`을 끊어주면 됩니다.
- 이 때, `삭제 연산`의 `시간 복잡도`는 탐색 과정 중에서 부모 노드에서 자식 노드로의 이동이 동반되기 때문에 트리의 높이에 비례하게 됩니다.
- 즉, `데이터의 개수`가 `N개`라면,
    - 균형잡힌 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(logN)$입니다.
    - 편향된 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(N)$입니다.
- 이 과정에서는 트리의 구조가 변경되지 않습니다.

<br />

### 삭제하려는 노드가 하나의 노드만 가지는 경우

- 삭제하려는 노드의 자식이 하나일 경우는 삭제할 노드가 존재하는 위치까지 탐색한 후에 `자식 노드`의 `자식 노드`를 `부모 노드`로 연결 시켜주면 됩니다.
- 이 과정도 동일하게 탐색이 필요하기 때문에 트리의 높이에 비례하게 됩니다.
- 즉, `데이터의 개수`가 `N개`라면,
    - 균형잡힌 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(logN)$입니다.
    - 편향된 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(N)$입니다.
- 이 과정에서는 트리의 구조가 변경되지 않습니다.

<br />

### 삭제하려는 노드가 두 개의 노드를 가지는 경우

- 삭제하려는 노드가 두 개의 노드를 가지는 경우에는 삭제될 위치의 노드를 삭제하지 않고 값만 변경하는 것으로 해결할 수 있습니다.
- 이 때, 삭제될 노드에 어떤 노드의 값을 넣어줘야할지 고민이 필요합니다.
- 이진탐색트리의 특성을 기반으로
    - 삭제될 노드 `왼쪽의 서브 트리`에는 `삭제될 노드의 값`보다 작아야하고
    - 삭제될 노드 `오른쪽 서브 트리`에는 `삭제될 노드의 값`보다 커야하기 때문에
- `삭제될 노드`에 들어가는 값은 `삭제될 노드`와 `가장 가까운 값`이라는 것을 알 수 있습니다.
- 따라서 `삭제될 노드`에 들어갈 값은 `왼쪽 서브 트리에서 가장 큰 값`과 `오른쪽 서브 트리에서 가장 작은 값` 중 하나를 옮기면 됩니다.
- 이 때, 옮겨지는 노드는 `하나의 노드 자식`만 가지거나 `자식이 없는 노드`이기 때문에, 위와 동일하게 `전자의 경우` `옮겨지는 노드`의 `부모노드`에 `자신의 자식 노드`를 연결 시키면 되고 `후자의 경우` 옮겨지는 노드는 삭제하면 됩니다.
- 이 과정도 삭제될 값을 탐색을 하고, 이와 제일 근사치의 값을 탐색해야 하기 때문에 트리의 높이에 비례한다고 할 수 있습니다.
- 즉, `데이터의 개수`가 `N개`라면,
    - 균형잡힌 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(logN)$입니다.
    - 편향된 이진탐색트리의 경우 탐색 과정에 대한 시간 복잡도는 $O(N)$입니다.
- 이 과정에서는 트리의 구조가 변경될 수 있습니다.

<br />

*<참고자료>*

- [[알고리즘] 제11-1강 이진검색트리(Binary Search Tree)](https://www.youtube.com/watch?v=4RmfHRZasoY)
- [이진탐색트리란?](https://github.com/wjdrbs96/Today-I-Learn/blob/master/Data_Structrue/Tree/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC%EB%9E%80%3F.md)

<br />
