# 메모리 계층구조
<br />

### 메모리 계층구조

- `메인 메모리`와 `레지스터` 같은 경우에는 CPU가 직접 접근할 수 있는 유일한 저장 장치입니다.
- 따라서 CPU의 모든 `명령어`와 `데이터`는 메인 메모리와 레지스터에 위치해 있어야 합니다.
- 일반적으로 대부분의 최신 CPU는 레지스터에  접근하고 처리하는데 `CPU 클록`의 `1사이클`이면 충분합니다.
- 하지만, 메인 메모리의 경우 접근하고 처리하는데 많은 사이클이 필요하게 됩니다.
- 다음 그림은 CPU와 메인 메모리의 성능의 발전 속도를 나타냅니다.
    
   <img width="700" alt="Untitled" src="https://user-images.githubusercontent.com/88137420/230906611-3edbae8e-c4b5-4b76-b072-a3e76f673da1.png">

    
- 이 과정에서 CPU가 명령어나 데이터를 가져오기까지 CPU의 작업(및 파이프라이닝)은 멈추게 되고, 이를 `메모리 스톨 현상`이라고 표현합니다.
    
    <img width="700" alt="Untitled1" src="https://user-images.githubusercontent.com/88137420/230906633-873156d8-3913-41c3-a766-8224b128f22f.png">
    
- 이러한 문제를 해결하기 위해 CPU와 메인 메모리 사이에 `캐시 메모리`를 사용해서 해결하고 있습니다.
- 즉, 모든 최신 프로세서에는 소량의 캐시 메모리가 있고, 지난 수십 년 동안 캐시 아키텍처는 점점 더 복잡해지며 발전하고 있습니다.
- 현재 CPU의 캐시 메모리는 `L1`, `L2` 및 `L3`로 구성으로 발전 되었고, 캐시가 가지는 각 `블록`의 크기도 증가했습니다.
    
    ![Untitled2](https://user-images.githubusercontent.com/88137420/230906824-5b71bd50-89be-486b-aa2f-470740d2792f.png)

    
<br />

### 캐시 메모리

- `캐시 메모리`는 훨씬 더 빠르고 고가의 `SRAM 기술`을 기반으로 하고 `메인 메모리`는 이보다 저렴하고 느린 `DRAM 기술`을 활용합니다.
- 또한 캐시 메모리는 `성능`과 `실패 손실`을 줄이기 위해 L1, L2, L3와 같이 서로 다른 속도와 크기를 가진 메모리로 구성되어 있습니다.
- 일반적으로 이러한 구조의 기본 아이디어는 `프로세서` 근처에 더 `작고 빠른 메모리`(`L1 캐시`)를 두고 `더 크고 느린 메모리`(`L2 혹은 L3 캐시`)를 멀리 두는 것입니다.
- 최신 CPU의 L1 캐시 같은 경우 최대 `512KB`(`코어 당 64KB`)의 메모리 공간을 할당 받습니다.
- 또한 L1 캐시의 경우 데이터를 저장하는 `L1-D 캐시`, 명령어를 저장하는 `L1-I 캐시`로 나뉘게 되는데, 이를 통해 명령어와 데이터를 동시에 엑세스할 수 있다는 특징을 가지고 있습니다.
- L2 캐시 같은 경우에는 최대 `4-8MB` (`코어 당 512KB`)의 메모리 공간을 할당 받습니다.
- L3 캐시 같은 경우에는 `10-64MB`까지 다양합니다. 서버용 컴퓨터에는 이보다 더 큰 메모리 공간을 할당하고 있습니다.
- 여기에서 L1 및 L2 캐시는 각 코어에 위치해있으며 L3 캐시는 모든 코어로부터 공유 된다고 할 수 있습니다.
- 일반적으로 CPU에 명령어나 데이터가 필요한 경우, 먼저 연결된 코어의 L1 캐시에서 검색하고 찾을 수 없는 경우 L2 및 L3 캐시에서 검색합니다.
- 필요한 명령어나 데이터가 발견되면 이를 `Cache Hit`(캐시 적중)이라고 하고 걸린 시간을 `적중 시간`(hit time)이라고 합니다.
- 반면에 필요한 명령어나 데이터가 캐시에 없으면, CPU는 데이터를 메인 메모리에서 가져와야 하는데 이를 `Cache Miss`(캐시 미스)라고 하고 이 과정에서 걸린 시간을 `실패 손실`(miss penalty)라고 합니다.
- 캐시 메모리 같은 경우에는 캐시 미스와 실패 손실 시간을 줄이는 방향으로 발전 되는데, 이를 위해 `시간적 지역성`과 `공간적 지역성` 매커니즘을 사용해서 해결하고 있습니다.

<br />

### 시간적 지역성 vs 공간적 지역성

- 이 두 가지 매커니즘 모두 경향성을 바탕으로 만들어졌습니다.
- 시간적 지역성
    - `시간적 지역성`(Temporal Locality) 같은 경우에는 프로세서가 동일한 메모리 위치에 있는 명령어나 데이터를 자주 액세스하는 경향을 바탕으로 만들어졌습니다.
    - 즉, 명령어나 데이터가 한 번 액세스되면 곧 다시 액세스할 가능성이 높다는 것을 의미하기에 이를 캐시 메모리에 넣어두고 빠르게 사용하는 것을 의미합니다.
    - 시간적 지역성의 예로는 재귀문이 있습니다.
- 공간적 지역성
    - `공간적 집약성`(Spatial Locality) 같은 경우에는 프로세서가 연속적으로 물리적으로 서로 가까운 메모리 위치에 액세스하는 경향을 바탕을 만들어졌습니다.
    - 즉, 명령어나 데이터가 한 번 엑세스 되면 일반적으로 순차적인 방식으로 데이터 및 명령에 액세스할 가능성이 높다는 것을 의미하기에 캐시 메모리에 넣어두고 빠르게 사용하는 것을 의미합니다.
    - 공간적 지역성의 예로는 배열이 있습니다.
- 정리해보자면, 이러한 시간적, 공간적 지역성 매커니즘을 통해서 자주 사용하는 명령어 및 데이터를  메인 메모리가 아니라 캐시 메모리에서 저장하고 빠르게 사용 한다는 것을 의미합니다.

<br />
<br />

*<참고자료>*

- [L1, L2 및 L3 캐시의 차이점: CPU 캐시는 어떻게 작동합니까?](https://quasarzone.com/bbs/qn_hardware/views/818208)
- COMPUTER ORGANIZATION AND DESIGN(MIPS Edition)-Chapter5 메모리 계층구조

<br />
