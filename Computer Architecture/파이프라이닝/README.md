# 파이프라이닝
<br>

### 파이프 라이닝을 사용하는 이유

- 싱글 코어를 기준으로 하나의 `CPU`는 `메모리`에 적재되어 있는 `하나의 명령어`만 처리할 수 있습니다.
- 이러한 특징으로 인해 2가지 측면에서 `비효율`이 발생하게 됩니다.
    - 첫 번째로 CPU에게 비효율적입니다.
        - 하나의 명령어를 처리할 때 모든 CPU를 사용하는 것이 아니기 때문에 비효율적이라고 할 수 있습니다.
    - 두 번째로 다음 명령어에게 비효율적입니다.
        - 현재 수행하고 있는 명령어가 굉장히 복잡한 명령어라면 다음 번에 수행되어야 하는 명령어는 이전의 명령어가 끝날 때까지 기다릴 수 밖에 없기 때문에 비효율적이라고 할 수 있습니다.
- 이러한 문제를 해결하고자 나온 것이 `파이프라이닝`입니다.
<br>

### 파이프라이닝이란

- 파이프라이닝(pipelining)은 여러 명령어가 중첩되어 실행되는 구현 기술을 의미 합니다.
- 즉, 파이프라이닝은 하나의 명령어 실행이 완료될 때까지 기다리지 않고, 다음 명령어를 순차적으로 실행하는 기술이라고 할 수 있습니다.
- 이러한 기술이 가능한 이유는
    - 하나의 명령어가 여러 단계로 나누어져 있고,
    - 단계가 겹치지 않는다면, CPU는 명령어를 함께 처리할 수 있는 특성 때문입니다.
<br>

### 명령어 사이클

- 명령어는 일반적으로 4개의 사이클로 나뉜다고 하고 이를 명령어 사이클이라고 합니다.
    
    <img width="700" alt="Untitled" src="https://user-images.githubusercontent.com/88137420/222609047-06e9f273-dca0-4a40-856a-8321159b0c94.png">

    
    1. `인출`(Fetch) 사이클
        1. 명령어 인출 사이클은 다음과 같습니다.
            1. CPU는 `프로그램 카운터`(PC)를 통해서 메모리에 있는 명령어 주소를 `MAR`(기억장치 주소 레지스터, Memory Address Register - `데이터를 읽거나 쓸 때, 해당 데이터가 저장된 메모리 주소를 보관하는 레지스터`)에 전달 받습니다.
            2. 이 후, CPU는 MAR은 명령의 주소로 참조하여 명령어를 가져와 `MBR`(기억장치 버퍼 레지스터, Memory Buffer Register - `데이터를 일시적으로 저장하는 레지스터`)에 저장을 하고 다음 명령어를 실행하기 위해 프로그램 카운터의 값을 증가 시킵니다.
            3. 이 후, CPU는 MBR에 있는 명령어를 `IR`(Instruction Register - `현재 실행 중인 명령을 기억하는 레지스터`)에 적재 합니다.
    2. `간접`(Indirect) 사이클
        1. 간접 사이클은 명령어에 포함되어 있는 주소 정보를 이용하여, 실제 명령어 실행에 필요한 `데이터`를 인출하는 사이클입니다.
        2. 실행 단계의 해독 단계와 실행 단계 사이에서 시작 됩니다.
        3. 명령어 간접 사이클은 다음과 같습니다.
            1. CPU는 명령어 레지스터(IR)에 있는 명령어를 실행 하는데 필요한 연산값들의 데이터 주소값을 MAR로 전달한다.
            2. CPU는 그 주소 값을 통해 기억장치로부터 데이터를 `데이터 버스`를 통해 가져와 `MDR`(Memory Data Register)에 저장한다.
    3. `실행`(Execute) 사이클
        1. 명령어 레지스터에서 가져온 명령어와 데이터를 연산하는 사이클 입니다.
            1. `해독`(decode) : 명령어를 해독 합니다.
            2. 실행(excute) : 해독한 명령어를 바탕으로 연산을 진행 합니다.
                1. 이 때, 명령어의 형식은 `연산 코드`와 오퍼랜드(명령에 필요한 데이터가 저장된 주소)로 구성되어 있습니다.
    4. `인터럽트`(Interrupt) 사이클
        1. 인터럽트 발생시 인터럽트를 처리하기 위한 단계입니다.
            
            <img width="700" alt="Untitled1" src="https://user-images.githubusercontent.com/88137420/222609081-cdfa304c-53fb-4b11-96cf-691e54646d86.png">

            
<br>

### 명령어 파이프라이닝 ?

- 파이프라이닝의 장점
    - 이러한 명령어 사이클에서 인터셉터 사이클을 제외하면 명령어 단계가 나오게 되는데,
    - 일반적으로 명령어는 간접 사이클을 제외하고 인출과 실행의 2단계로 나눠져 있습니다.
    - 하지만, 이러한 명령어를 효과적으로 `단계적 병렬 처리`하기 위해서 4, 5, 6단계로 나누고, 이를 파이프라이닝이라고 합니다.
    - 이론적으로 파이프라이닝을 완벽하게 구축한다면 명령어의 단계의 수만큼 비례해서 빨라지는 특성을 가지고 있습니다.
    - 예를 들어 명령어가 4단계(인출, 해독, 오퍼랜드 인출, 실행)로 나뉘어 있다면,
        - 10회시 40/13 = 3.07…
        - 100회시 400/103 = 3.88…
        - 1000회시 4000/1003 = 3.98…
    - 즉, 명령어의 단계가 고정되어있고 명령어가 무한에 가깝게 있다면 단계의 수만큼 비례해서 빨라지게 된다는 특징을 가지고 있습니다.
    - 여기에서 두 가지의 조건이 더 붙게 되는데,
    - 하나는 각 명령어의 단계의 시간이 `일정`해야한다는 점과 모든 명령어가 같은 단계로 나뉘어져있다고 가정을 해야하는 특성이 있습니다.
    - 이에 더하여 실제 환경에서는 단계의 수만큼 비례하지 않고 성능을 저해하는 다른 요소들이 존재 하는데 이를 파이프라이닝 해저드라고 한다.
<br>

### 파이프라이닝 해저드의 종류

- 구조적 해저드
    - 구조적 해저드는 하드웨어 자원의 한계로 발생하는 해저드입니다.
- 데이터 해저드
    - 데이터 해저드는 데이터 의존성으로 발생하는 해저드입니다.
    - 예를 들어, 이전 명령어의 결과를 사용해야 하는데, 이전 명령어의 실행이 끝나지 않은 경우 데이터 해저드가 발생 합니다.
- 제어 해저드
    - 명령어의 실행 순서를 변경하는 Jump와 같은 명령어에 의해 발생하는 해저드입니다.
    - 예를 들어, 인터럽트 발생으로 인해서 프로그램 카운터가 특정 다른 주소로 이동을 하게되면 제어 해저드가 발생 합니다.
<br>

*<참고자료>*

- [[컴퓨터 공학 기초 강의] 13강. 명령어 병렬 처리 기법](https://www.youtube.com/watch?v=Btsa_U-f26k&t=952s)
- [제4장 명령어 처리](https://slidesplayer.org/slide/14034395/)
<br>
