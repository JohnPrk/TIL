# 어노테이션

<br>

### 어노테이션

<br>

- 일반적으로 어노테이션은 클래스나 메소드, 변수 등 모든 요소 선언시에 @을 통해서 사용할 수 있습니다.
- 어노테이션은 다음과 같은 이유로 사용 된다고 할 수 있습니다.
    - 컴파일러에게 어떠한 정보를 알려줄 때 사용합니다.
    - 해당 클래스나 메서드 및 변수가 선언되거나 실행되는 상황에서 별도의 처리가 필요할 때 사용합니다.

<br>

### 자바가 제공하는 어노테이션

- 자바가 제공하는 어노테이션은 3가지가 있는데 다음과 같습니다.
- @Override
    - 일반적으로 `@Override` 어노테이션은 메서드에 적용하며, 부모 클래스의 메서드를 재정의 하겠다는 것을 컴파일러에게 명시적으로 알려주기 위해 사용됩니다.
    - 하지만, 굳이 @Override를 하지 않더라도 자식 클래스에서 부모 클래스의 메서드의 이름과 파라미터의 타입과 순서를 맞추면 부모 클래스의 메서드를 재정의 할 수 있습니다.
    - 하지만, 여기에서 개발자의 오류로 인해서 위의 조건을 만족하지 않는다면 런타임 시점에서 재정의된 메서드가 아니라 별도의 메서드로 처리되게 됩니다.
    - 만약, 상속받은 구현체가 필요한 부모 클래스나 인터페이스의 메서드를 자식 클래스에서 재정의하지 않을 경우 컴파일 오류가 발생합니다.
- @Deprecated
    - 일반적으로 `@Deprecated` 어노테이션은 어떠한 특정한 클래스 또는 메서드가 계도 기간을 거쳐서 향후 제거될 수 있으므로 사용하지 않도록 컴파일러에게 알려주기 위해서 사용됩니다.
    - 즉, 개발자가 이를 모른채 사용한다면 컴파일러가 이를 알려주는 역할을 한다고 할 수 있습니다.
    - 하지만, 이러한 경고는 컴파일 오류를 의미하는 것은 아니기 때문에 사용은 할 수 있습니다.
- @SuppressWarnings
    - 일반적으로 `@SuppressWarnings` 어노테이션은 컴파일 중에 생성된 지정된 경고를 억제하도록 컴파일러에 지시하는 데 사용됩니다.
    - 이는 특정 경고를 알고 있지만 특정 사례에서 문제가 되지 않는다고 판단한 경우에 유용할 수 있습니다.
    
<br>

### 사용자 지정 어노테이션을 위한 어노테이션

- Java에서 사용자 지정 어노테이션을 만들 때, 몇 가지 특정한 메타 어노테이션을 사용하여 사용자 지정 주석의 특성과 동작을 정의합니다.
- 몇 가지 특정한 어노테이션은 다음과 같습니다.
    1. @Target
        1. 사용자 지정 어노테이션을 사용할 때 사용하는 위치가 클래스 단위인지, 메서드 단위, 변수 단위인지 알려주기 위해 사용된다고 할 수 있습니다. 
        2. 이 때, ElementType을 통해 명시하는데 하나 이상의 값이 들어갈 수 있습니다.
    2. @Retention
        1. 사용자 지정 주석을 유지해야 하는 기간을 지정할 수 있고 이를 통해 어노테이션의 수명 주기를 정할 수 있습니다.
        2. 이 때, RetentionPolicy를 통해 명시 하는데 런타임 시점일지 클래스 파일 시점일지 소스 코드 시점일지에 대한 정보를 표시할 수 있습니다.
            1. RUNTIME
                - RetentionPolicy.RUNTIME 정책은 애플리케이션 실행 중에 `JVM` 또는 `프레임워크`가 어노테이션이 붙은 클래스, 메서드, 변수에 액세스하고 처리할 수 있기 위해 다양하게 사용된다고 할 수 있습니다.
                - 일반적으로 런타임 중에 Reflection API를 사용하여 어노테이션이 붙어 있는 데이터에 접근해서 사용하는 것을 의미합니다.
                - 이에 대한 몇 가지 예로 컴포넌트 스캔, JPA ORM 매핑, JUnit 등에 사용될 수 있습니다.
                    - `컴포넌트 스캔`은 Reflection API를 통해 이뤄지는데, 스프링의 @Controller, @Service, @Component, @Bean이 붙어 있는 어노테이션이 있는 클래스 혹은 메서드를 IoC 컨테이너의 빈으로 등록할 수 있습니다.
                    - `JPA ORM 매핑`은 @Entity, @Table, @Column 등과 같은 어노테이션을 사용하여 Java 개체와 데이터베이스 테이블 간의 매핑하고 데이터베이스에서 데이터 쿼리, 지속 또는 업데이트와 같은 작업을 수행할 수 있습니다.
                    - `JUnit`은 `@Test`, `@Before` 또는 `@After`와 같은 어노테이션을 사용하여 테스트 순서를 명시적으로 결정해서 테스트 진행을 구성할 수 있습니다.
            2. SOURCE
                - RetentionPolicy.SOURCE 정책은 `정적 코드 분석` 또는 `컴파일 단계`까지만 정보가 필요할 때 사용 된다고 할 수 있습니다.
                - 따라서 컴파일 과정에서 바이트 코드로 변환되지 않고 메모리에 올라가지 않고 사라진다는 것을 의미하게 됩니다.
                - 따라서 SOURCE로 지정된 어노테이션은 컴파일 시점까지의 특정한 작업을 위해 사용된다고 할 수 있습니다.
                - 예를 들자면, 어노테이션은 `정적 코드 분석`을 위해 통합 개발 환경(IDE)에 정보를 제공할 수 있습니다.
                - 이러한 주석은 컴파일된 바이트코드에 적용되지 않지만 코딩 프로세스 중에 개발자가 소스 코드 수준에서 잠재적인 문제나 위반 사항을 식별해서 컴파일 전에 해결할 수 있습니다.
                - 또한 일반적으로 가장 자주 사용되는 어노테이션으로는 `@Getter` 및 `@Setter`와 `생성자를 만드는 어노테이션` 등이 있는데, 이는 롬복의 도움을 받아서 처리된다고 할 수 있습니다.
                - 컴파일 하는 과정에서 컴파일러는 롬복 주석을 감지하고 롬복 어노테이션 프로세서가 호출되어 필요한 바이트 코드를 생성하는 과정을 거칩니다.
            3. CLASS
                - RetentionPolicy.CLASS 정책은 RetentionPolicy의 default 값이라고 할 수 있고, 컴파일된 바이트 코드 파일 시점까지 어노테이션이 남아 있고 메모리에는 올라가 있지 않는 것을 의미합니다.
                - 사실 리플랙션이 되지 않는 점에서 바이트 코드가 왜 있어야하는지 의문이 들기도 하는데 다음과 같은 블로그의 내용에서 자세히 설명해줍니다.
                    
                    <aside>
                    ☕ RetentionPolicy.CLASS 정책은 왜 필요한가?
                    
                    - 스택오버플로우('retention-of-java-type-checker-annotations') 글에 설명이 되어있는데, 인텔리제이를 써보셨다면, @NonNull 등이 붙어있는 경우 null 값을 넣게되면 노랑색 경고로 알려줍니다.
                    - "아니 그러면 SOURCE로 해도 될거 같은데?" 싶으실텐데요, 중요한점은 Maven/Gradle로 다운받은 라이브러리와 같이 jar 파일에는 소스가 포함되어있지 않다는 점입니다.
                    - 즉, class 파일만 존재하는 라이브러리 같은 경우에도 타입체커, IDE 부가기능 등을 사용할수 있으려면 CLASS 정책이 필요하게 됩니다.
                    </aside>
                    
                
<br>

### *<참고 자료>*

- [아무 관심 없던 @Retention 어노테이션 정리(RetentionPolicy SOURCE vs CLASS vs RUNTIME)](https://jeong-pro.tistory.com/234)
